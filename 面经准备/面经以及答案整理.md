

面经总结

## 深信服

![D CHANGED IN A FEW SECONDS](/Users/una/newroot/本地图床/D CHANGED IN A FEW SECONDS.png)

### 1. swift与go的区别

跨平台性：swift 是苹果的御用语言 虽然开源目前很大程度是与微软推出的.NETCore差不多，只支持Ubuntu 还是指定版本的。go目前是真正的跨平台语言，主流的系统和CPU架构都有支持。

语言特性：swift产生比go要晚一点，设计思想与go不同，swift有一点想玩一把编程语言集大成者的意思，几乎把其他现有语言的先进特性都吸收了过来，在此基础上还把编程人员经常诟病或是烦人的地方进行有特性功能扩展（比如协议支持默认实现  对象类可以不实现从协议中继承一部分代码  很多程度上避免了代码重复）。通过这些特性使得原来语言的编程人员很快发现与swift相同或相似的地方，随着深入逐渐发现swift语言特性，学习曲线比较平滑。 但是同时也带来了类似C++的问题，因为swift支持多范式编程，融合了很多特性，实现功能往往有很多种设计或实现方式而且差异很大。所以有时候会出现同样是swift程序员，但是互相不习惯对方的代码，更严重的情况下甚至看不懂。然而真的掌握这么多的设计模式或范式无形中提高的门槛，一定程度上把不同程度上的人群起到分离作用。而且目前没有工业化标准，就是定标准也是很麻烦的事，定的太高能达到的人很少，会出现有标准每人管的现象，如果定的比较低，swift语言特性在大部分时间都是多余的。

swift 是多范式编程语言。可结构化编程struct enum，可面向对象class，可面向协议protocol，可函数式 high-order，pure function。

从数据结构上来看，swift提倡多用struct enum少用class。抽象上提倡protocol-oriented（能用在class上，也能在struct上，比java接口更强大），最重要的，不要忘了function也是非常重要的数据结构，利用high-order可以写出复用性更好的代码，利用pure function写出更健壮的代码。

go的最大优势就是执行速度和开发效率都很出色，而且从语言级别上支持并发。执行速度快是因为go是编译型的静态语言，它在执行速度上比解释型语言具有先天的优势。生产效率高是基于go的语法和结构简明，易学易用。 go出现之前，无论汇编语言、还是动态脚本语言，在执行效率和开发效率上都不能兼备。

### 2. siwft与js的类似与区别

**Swift 是一个「JavaScript 风格的 C#」**

（1）层次结构

* 两者都可以在 **全局** 执行语句和表达式。当然，这并不是什么脚本语言的专利，C语言都可以。相比Java和C#只能在类的方法（或初始化及匿名代码块？）里执行语句要人性化很多。

两者都有相应的 **依赖机制**，但Swift是基于 **文件无关的 Module**（类似于C#那样层次化的命名空间）的；而 JavaScript 是基于 **文件路径** 的。因此对于相同复杂程度的依赖，JavaScript 往往需要更多的 import 关键字（恰好两者关键字都是 import ）。

（2）类型

* Swift 为 **强类型、静态类型**；JavaScript 为 **弱类型、动态类型**

Swift 具有一个可选的 **显式类型** 声明语法，也可依靠类型推理使用 **隐式类型**。

* 两者都有 **类** 语法，但 Swift 除了 Class（引用类型，堆内存）之外还支持 Structure （值类型，栈内存）。

*  继承方面，Swift 支持 **协议**（Protocol）类型（可以声明式多继承）；而 JavaScript 并没有接口类型（只能单继承）

* 数值类型方面，Swift 区分整型（Int 等）和浮点型（Float 等）数值，并且区分有符号和无符号类型；而 JavaScript 只有基于64位浮点型的 Number 类型数值。

* 字符类型方面，Swift区分字符（Character）和字符串（String）；而 JavaScript 中只有字符串。

Swift 支持可空类型（T?）和不可空类型（T!），并且支持空接合运算；JavaScript 只能靠团队约定或逐级检查。

（3）基本语法

* Swift 中，**var** 为变量，**let** 为常量；而 JavaScript 中，**var** 为函数作用域变量，**let** 为块作用域变量，**const** 为常量

两者都有 **可选分号**，Swift 不推荐使用分号，JavaScript 写不写分号的争议较大。

两者都支持 **字符串内插**

* Swift 中 **不论字符还是字符串** 都是双引号（**"**），靠变量类型来逆推表达式类型；
  而 JavaScript 中字符串既可以用双引号（**"**）也可以用单引号（**'**）以及反引号（**`**）（模板字符串）。

（4）**函数**

函数返回值方面，两者都支持表观上的函数 **多返回值**，Swift 靠的是元组语法，JavaScript 靠的是对象/数组解构语法（此处以对象解构为例）。

函数参数方面，两者都支持 **可选参数**。

函数参数方面，两者都支持 **不定项参数**。

（5）**容器**

两者有相似的 **原生容器类型**，Swift 的原生容器有 Array、Set、Dictionary；JavaScript 有Array、Set、WeakSet、Map、WeakMap。(Object不是容器）

两者都支持较为简洁的 **初始化** 语法。

* Swift 支持 **可访问性** 修饰符，对成员可以设置（private、internal、public等）不同的访问级别；
  JavaScript 没有可访问性限制，除了构造特殊闭包外所有成员均可视为 public。

Swift 支持 **扩展方法**，JavaScript 本来就是动态类型可以对原型随便加方法。

### 3. 静态数据动态数据 强类型语言弱类型语言

https://www.zhihu.com/question/19918532

*强类型strongly typed*: 结果角度看，如果一种语言的所有程序都是well behaved——即不可能出现forbidden behaviors，则该语言为strongly typed。直接报错。原因角度看inferred type（推断式语言）在编译时确定此变量类型，不能出现类型转换。

*弱类型weakly typed*: 否则为weakly typed。比如C语言的缓冲区溢出，属于trapped errors，即属于forbidden behaviors..故C是弱类型。可能出现隐式转换。弱语言允许将一块内存看作多种类型。

*静态类型 statically*: 如果在编译时拒绝ill behaved程序，则是statically typed;

*动态类型dynamiclly*: 如果在运行时拒绝ill behaviors, 则是dynamiclly typed。

*Forbidden Behaviours*：语言设计时，可以定义一组 forbidden behaviors. 它必须包括所有untrapped errors, 但可能包含trapped errors.

*Errors ：*

* *trapped errors*。导致程序终止执行，如除0，Java中数组越界访问 

* *untrapped errors*。 出错后继续执行，但可能出现任意行为。如C里的缓冲区溢出、Jump到错误地址

*Well behaved、ill behaved*

- *well behaved*: 如果程序执行不可能出现forbidden behaviors, 则为*well behaved*。
- *ill behaved: 否则为ill behaved...*

无类型： 汇编
弱类型、静态类型 ： C/  C++（混血）
弱类型、动态类型检查： Perl/PHP/js
强类型、静态类型检查 ：Java/C#/swift
强类型、动态类型检查 ：Python, Scheme
静态**显式**类型 ：Java/C
静态隐式类型 ：Ocaml, Haskell

### 4. interface，抽象类与继承

interface是面向对象编程语言中接口操作的关键字，功能是把所需成员组合起来，用来装封一定功能的集合。它好比一个模板，在其中定义了对象必须实现的成员，通过类或结构来实现它。接口不能直接[实例](https://baike.baidu.com/item/实例)化，即ICount ic=new iCount()是错的。接口不能包含成员的任何代码，只定义成员本身。接口成员的具体代码由实现接口的类提供。接口使用interface关键字进行声明

与类相似，接口可以包含方法、属性、索引器和事件作为成员。接口中可以声明属性、方法、事件和类型(Structure)，（但不能声明变量），但是并不能设置这些成员的具体值，也就是说，只能定义，不能给它里面定义的东西赋值。

**声明格式**如下：

[attributes] [modifiers] interface identifier [: base-list] {interface-body} {;}

1、attributes（可选）：附加的定义性信息。

2、modifiers（可选）： 允许使用的修饰符有 new 和四个访问修饰符。分别是：new、public、protected、internal、 private。在一个接口定义中同一修饰符不允许出现多次，new 修饰符只能出现 在嵌套接口中，表示覆盖了继承而来的同名成员。The public, protected, internal, and private 修饰符定义了对接口的访问权限。

3、指示器和事件。

4、identifier：接口名称。

5、base-list（可选）:包含一个或多个显式基接口的列表，接口间由逗号分隔。

6、interface-body：对接口成员的定义。

7、接口可以是命名空间或类的成员，并且可以包含下列成员的签名： 方法、属性、索引器 。

8、一个接口可从一个或多个基接口继承。

C#和Java一个接口可以扩展一个或者多个其他接口。

**接口的成员变量**

接口中的成员变量具有公共性（public）、静态性（static）和最终性（final）。所以修饰符只能是public，因此只能定义常量。接口中的属性都是静态常量，方法都是抽象方法（即没有给出方法具体定义），一个类实现接口后，将继承接口中的所有静态常量。

**实现接口类**

实现多接口的类必须符合3个原则：能为所有的接口提供实现的功能，能遵循重写的所有规则，能保持相同的返回的数据类型。

**接口继承**

接口可以[多继承](https://baike.baidu.com/item/多继承/7705685)接口 因为接口只定义行为 并不包含类别的含义 不指代具体的某类事物 而且 从语义上来说 接口对接口的继承称之为扩展更为合适

接口可以多继承，是因为接口中只有抽象方法，没有静态方法和非常量的属性，只有接口的实现类才会重写接口中方法。因此一个类有多个接口也不会增加JVM的绑定机制和复杂度。

**类继承**

java类继承是单继承：当子类重写父类方法的时候，或者隐藏父类的成员变量以及静态方法的时候，JVM使用不同的绑定规则。如果一个类有多个直接的父类，那么会使绑定规则变得更复杂。为了简化软件的体系结构和绑定机制，java语言禁止多继承。

**接口与抽象类区别**

共同点如下：
1)	都是上层的抽象层。
2)	都不能被实例化
3)	都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不比提供具体的实现。
区别如下：
1)	在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。
2)	一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。

### 5. Go goroutine 和 channel 

http://wecatch.me/go/posts/go-goroutine-channel-1/#:~:text=%E5%AE%9A%E4%B9%89,%E7%A7%B0%E4%B9%8B%E4%B8%BA%20main%20goroutine%20%E3%80%82&text=%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%BE%8B%E5%AD%90%E4%B8%AD%EF%BC%8C%20go,%E4%B8%A4%E4%B8%AA%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C%E3%80%82

Go 支持两种方式的并发模型: communicating sequential processes(CSP) 和 shared memory multithreading，前者是 goroutine 和 channel 并发模型实现的基础，后者是传统的共享内存的方式，也就是多线程模型。

如何理解 CSP ？简单来说就是通过在不同的 goroutine 之间传递 value 来维护并发的下不同 goroutine 的状态，但是对变量的使用、修改要限制在单一的 goroutine 中。

**Goroutine 定义**

在 Go 中可以并发执行的活动单元称之为 goroutine。当一个 Go 程序启动时，一个执行 main function 的 goroutine 会被创建，称之为 `main goroutine`。创建新的 goroutine 可以使用 go 语句，像这样: go f()，其中 `f` 是一个函数。使用 go 语句开启一个新的 goroutine 之后，go 语句之后的函数调用将在新的 goroutine 中执行，而不会阻塞当前的程序执行。

**Goroutine使用例子**

客户端收服务端请求并且回显，如果不用goroutine，则在两个终端窗口开的客户端只能有一个工作。但是使用go关键字打开goroutine，则可以并发。

**channel 定义**

如果说 goroutine 是并发执行的一个 Go program， channel 就是它们之间的连接通道，它提供了 goroutine 之间相互通信的机制。Channel 是有类型的，channel 中使用的 type 称之为 element type，比如 int 类型的 channel 写作为 `chan int`。

Go 使用 make 内建函数创建 channel。

```go
ch := make(chan int)
```



同 map 一样，一个 channel 引用着 make 创建的底层数据结构上，当把 channel 当做函数参数传递时，实际上是拷贝一份 reference，也就是说函数内部和外部引用的是相同的数据结构，所以在函数内部可以直接修改 channel 的值。同其它 reference type 一样，**channel 的 zero value 是 nil**。

**Channel 是可比较的，如果两个 channel 的类型相同，它们可以彼此相互比较**，当然 channel 也可以和 nil 比较。

**channel 基本操作**

Go 使用 `<-` 操作符来实现 send 和 receive。Send 操作 `<-` 在 channel 右侧，receive 操作 `<-` 在左侧。

```go
ch <- x //send
x = <- ch //receive
<- ch //receive
```

Channel 还支持第三种操作 `close`，如果 channel 被 close，表明 channel 不会再 send 任何值了，如果还继续对 channel 执行 receive 操作，等 channel 中的值消耗完毕之后，之后返回的是对应 element type 的 zero value，如果对 channel 执行 send 操作，将会引起 panic。

```go
close(ch)
```

**Unbuffered channel**

在创建 channel 时可以指定 channel 的容量，如果不指定默认是 0，我们称这种 channel 是 unbuffered channel。

如果在一个 goroutine 中对 unbuffered channel 执行 send 操作将会一直阻塞，直到有另一个不同的 goroutine 对同样的 channel 开始执行 receive 为止，此时通过 channel send 的值会发送到接收端，之后两个 goroutine 才会各自继续执行。

相似地，如果是 receive 操作先执行，也是类似的过程。

**正是因为 unbuffered channel 的这种特性，unbuffered channel 也称之为 synchronous channel**(同步管道)。

```go
package main
import (
    "fmt"
)

func main() {
    c := make(chan int)
    go func(){
        c <- 1
    }
    <-c
    fmt.Println("main goroutine finish ")
}
```

上面的代码展示了利用 unbuffered channel 完成同步的能力，main goroutine 会一直等待直到满足特定条件时才会结束。

### 6. defer，panic 和 recover

https://blog.csdn.net/Jmilk/article/details/107449462

Golang 中常规的错误处理方式是直接 return error 给调用者，再由调用者决定后续的程序逻辑，或捕获、或终止、或恢复。但对于一些无法恢复的错误，返回 error 也没有意义，此时可以考虑使用 panic（惊恐）语句，表示一种自动触发的错误。除了在代码中主动触发 panic，在程序运行的过程中也可能会因为出现某些错误而触发 panic，例如：数组越界。

**panic 会退出当前正在执行的程序**（注意，不只是 Goroutine 协程），但是与 `os.Exit(-1)` 此类 “义无反顾” 的退出不同，panic 的退出更加的 “井然有序”，**panic 会先递归的处理完当前 Goroutine 已经 defer 上去的任务(defer 调用逆序)**，执行完毕后再打印调用栈，最终调用 `exit(-2)` 退出整个进程。

相对的，**recover（恢复）关键字可以恢复 panic 造成的程序终止**，并且 recover 是一个只能在 defer 函数中发挥作用的函数，在其他作用域中调用不会发挥任何作用。

可见，defer、panic、recover 三者的组合可以完成一种灵活的程序流控制。比如：在 defer 中通过 recover 截取 panic，从而达到 try/catch 的效果。

panic 终止了程序，并且是在执行完挂载到 Goroutine 的 defer 之后退出的，同时还打印了错误堆栈。注意，当一个 Goroutine 挂载了多个 defer 的话，其执行顺序是后进先出的，即逆序执行。另外，panic 仅能保证递归当前 Goroutine 下的所有 defer 都会被调用，但不保证其他的 Goroutine。

recover，顾名思义是恢复被 panic 退出的程序流，是 Golang 的 handle panic（异常处理）机制.recover 只在 defer 函数中有效，如果不是在 refer 上下文中调用 recover 会直接返回 nil。

例子：

```go
package main

import (
    "fmt"
    "os"
    "time"
)

func main() {
    defer fmt.Println("defer main") // will this be printed when panic?

    var user = os.Getenv("USER_")

    go func() {
        defer fmt.Println("defer caller")
        func() {
            defer func() {
                fmt.Println("defer here.")
                if err := recover(); err != nil {
                    fmt.Println("recover success.")
                }
            }()

            if user == "" {
                panic("should set user env.")
            }
        }()
    }()

    time.Sleep(1 * time.Second)
    fmt.Println("get result")
}
```

结果：

```
$ go run main.go
defer here.
recover success.
defer caller
get result
defer main
```

### 7. mutex 锁：互斥锁

https://blog.csdn.net/qq_33951180/article/details/72801228#:~:text=%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E4%B8%80%E7%82%B9%EF%BC%8C%E4%BA%92,%E8%8E%B7%E5%BE%97%E9%94%81%E6%88%96%E9%87%8A%E6%94%BE%E9%94%81%E3%80%82&text=2%E3%80%81%E4%BD%9C%E7%94%A8%EF%BC%9A%E4%BA%92%E6%96%A5%E9%94%81,%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%92%E6%96%A5%E3%80%82

**概念：**

临界资源：能够被多个线程共享的数据/资源。临界区：对临界资源进行操作的那一段代码

**互斥锁的本质**：
首先需要明确一点，互斥锁实际上是一种变量，在使用互斥锁时，实际上是对这个变量进行置0置1操作并进行判断使得线程能够获得锁或释放锁。

**作用：**互斥锁的作用是对临界区加以保护，以使任意时刻只有一个线程能够执行临界区的代码。实现了多线程之间的互斥。

**使用互斥锁主要有以下几个接口操作：**

```C++
//两种方法对锁进行初始化
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
              const pthread_mutexattr_t *restrict attr);
//互斥锁的销毁
int pthread_mutex_destroy(pthread_mutex_t *mutex);

//获得锁
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);

//释放锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);12345678910111213
```

pthread_mutex_lock：如果此时已经有另一个线程已经获得了锁，那么当前线程调用该函数后就会被挂起等待，直到有另一个线程释放了锁，该线程会被唤醒。
pthread_mutex_trylock：如果此时有另一个贤臣已经获得了锁，那么当前线程调用该函数后会立即返回并返回设置出错码为EBUSY，即它不会使当前线程挂起等待。

**互斥锁的底层实现：**

上边已经提到，mutex的本质是一种变量。假设mutex为1时表示锁是空闲的，此时某个进程如果调用lock函数就可以获得所资源；当mutex为0时表示锁被其他进程占用，如果此时有进程调用lock来获得锁时会被挂起等待。

```C++
lock:
	if(mutex > 0){
		mutex = 0;
		return 0;
	}else{挂起等待}
	goto lock
unlock:
	mutex += 1;
	唤醒线程
	return 0;
```

**死锁**

指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所占用不会释放的资源而处于的一种永久等待状态。可能由系统资源不足，申请锁的顺序不当引起。

**死锁产生的条件**
1、互斥属性：即每次只能有一个线程占用资源。
2、请求与保持：即已经申请到锁资源的线程可以继续申请。在这种情况下，一个线程也可以产生死锁情况，即抱着锁找锁。
3、不可剥夺：线程已经得到所资源，在没有自己主动释放之前，不能被强行剥夺。
4、循环等待：多个线程形成环路等待，每个线程都在等待相邻线程的锁资源。

**死锁的避免：**
1、既然死锁的产生是由于使用了锁，那么在能不使用锁的情况下就尽量不使用，如果有多种方案都能实现，那么尽量不选用带锁的这种方案
2、尽量避免同时获得多把锁，如果有必要，就要保证获得锁的顺序相同

### 8. 互斥锁、条件锁、读写锁以及自旋锁

https://www.zhihu.com/question/66733477

自旋锁   while while while 地检查是否能够加锁，浪费 CPU 做无用功。

```
while(没抢到锁){
				keep try 
}
```

互斥锁

为了实现「锁的状态发生改变时再唤醒」就需要把锁也交给操作系统管理。 互斥器的加锁操作通常都需要涉及到上下文切换，操作花销也就会比自旋锁要大。

```
if(mutex > 0){
		mutex = 0;
		return 0;
	}else{挂起等待}
	goto lock
```

条件锁

不是while等待抽象资源是否可用（操作系统控制），而是用事物逻辑控制。条件锁指条件变量，它本身不是锁，而是一种线程通信机制，与互斥量一起使用。

只要某个被锁的条件不发生变化，while循环就没必要进行加锁，判断，条件不成立，解锁的过程。

条件锁的意义是在于通过手写的事物逻辑判断什么时候结束等待。一般来说先解锁互斥量，再解锁条件变量。（因为解锁了条件变量可能让多个等待的条件变量被唤醒了）

使用条件变量，就可以让甲每取出一个任务就发一个通知，然后操作系统自动转发通知给乙（所谓“转发通知”，实质上是，平常乙执行“等待条件变量”系统调用、然后因条件得不到满足而被操作系统自动挂起；等条件满足了，操作系统才会让其继续执行）。

```
while(某个被锁保护条件是否达成){
				解锁等待通知唤醒再加锁（用于收发通知的条件，互斥量）
}


```

while而不使用if的原因：

1. 避免群惊
2. 避免线程虚假唤醒。即没有pthread_cond_signal就解除了阻塞

读写锁

由上述锁完成

### 9. ps top netstat ln 命令

**ps:**

Process Status.ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。

**netstat**

Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。

Netstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。Netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。	

**netstat**命令的功能是显示网络连接、路由表和网络接口信息，可以让用户得知有哪些网络连接正在运作。 [1] 使用时如果不带参数，**netstat**显示活动的 TCP 连接。

**ln:**

它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。

### 10. ln- 软连接硬连接

ln的链接又分软链接和硬链接两种

* 软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间

* 硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。

区别：

1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式

2.软链接可以 跨文件系统 ，硬链接不可以

3.软链接可以对一个不存在的文件名进行链接

4.软链接可以对目录进行链接

5.硬链接，以文件副本的形式存在。但不占用实际空间。

6.不允许给目录创建硬链接

7.硬链接只有在同一个文件系统中才能创建

### 11. 排序

https://www.cnblogs.com/onepixel/p/7674659.html

排序分类

- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
- **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

* 比较类

  * 交换排序
    * 冒泡排序 					
    * 快速排序

  * 插入排序
    * 简单插入排序
    * 希尔排序

  * 选择排序
    * 简单选择排序
    * 堆排序
  * 归并排序
    * 二路归并
    * 多路归并

* 非比较类

  * 计数排序
  * 桶排序
  * 基数排序

相关概念

- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- **不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- **时间复杂度**：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- **空间复杂度：**是指算法在计算机

#### 冒泡

时间平均 (n^2) 时间最差(n^2) 时间最好(n) 空间(1) 稳定

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

```python
for i in range(len(listOfNum)):
	ifSwap = 0
	for j in ranege(i):
		if listOfNum[j] > listOfNum[j+1]:
			swap(listOfNum[j] , listOfNum[j+1])
			ifSwap = 1
	if ifSwap == 0:
		return
```

#### 快速排序

最好： nlog2n 最差 n^2 平均 nlog2n 空间nlog2n 不稳定

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

```python
class Solution:
    def participite(self, listSort, left, right):
        girl = left+1
        standard = listSort[left]
        for boy in range(left+1, right+1):
            if listSort[boy] <= standard:
                listSort[boy], listSort[girl] = listSort[girl], listSort[boy]
                girl += 1
        listSort[left], listSort[girl-1] = listSort[girl-1], listSort[left]
        return girl-1

    def quikSort(self, listSort, left, right):
        if left >= right:
            return
        pi = self.participite(listSort, left, right)

        self.quikSort(listSort, left, pi-1)
        self.quikSort(listSort, pi+1, right)

        return listSort
      
test = Solution()
listSort = [4, 2, 3, 5, 8, 1, 9, 0, -3]
print(test.quikSort(listSort, 0, 8))
```

计算复杂度

https://www.zhihu.com/question/22393997



## 深信服 python 面经



### 1. [链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)和数组的区别，如何用python实现。

* 数组：相同数据类型的元素按一定顺序排列的集合；数组的存储区间是连续的，占用内存比较大，故空间复杂的很大。数组的特点是：查询简单，增加和删除困难；因为数组的内存是连续的，想要访问那个元素，直接从数组的首地址向后偏移就可以访问到了。从**栈分配**的。

* 链表:链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：查询相对于数组困难，增加和删除容易。链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 链表的空间是从**堆中分配**的。

python 

```python
class Node(object):
    """define the node"""

    def __init__(self, item):
        # save item
        self.item = item
        # next
        self.next = None
```

### 2. \__init__ 和 \___new___的区别

https://blog.csdn.net/luoweifu/article/details/82732313

**new**为对象分配空间，是内置的静态方法，**new**在内存中为对象分配了空间也返回了对象的引用，**init**获得了这个引用才初始化这个实例。

`__new__`所接收的第一个参数是`cls`，而`__init__`所接收的第一个参数是`self`。这是因为当我们调用`__new__`的时候，该类的实例还并不存在（也就是`self`所引用的对象还不存在），所以需要接收一个类作为参数，从而产生一个实例。而当我们调用`__init__`的时候，实例已经存在，因此`__init__`接受`self`作为第一个参数并对该实例进行必要的初始化操作。这也意味着`__init__`是在`__new__`之后被调用的。`__new__`作为构造器，起创建一个类实例的作用。而`__init__`作为初始化器，起初始化一个已被创建的实例的作用。

`__new__`函数首先被调用，构造了一个`newStyleClass`的实例，接着`__init__`函数在`__new__`函数返回一个实例的时候被调用，并且这个实例作为`self`参数被传入了`__init__`函数。

```python
class A(object):  # -> don't forget the object specified as base

    def __new__(cls):
        print "A.__new__ called"
        return super(A, cls).__new__(cls)

    def __init__(self):
        print "A.__init__ called"

A()
```

```
A.__new__ called
A.__init__ called
```

__new__ 是在我们调用类名进行实例化时自动调用的，__init__ 是在这个类的每一次实例化对象之后调用的

**注意1**：如果`__new__`函数返回一个已经存在的实例（不论是哪个类的），`__init__`不会被调用。如下面代码所示：

```python
obj = 12 
# obj can be an object from any class, even object.__new__(object)

class returnExistedObj(object):
    def __new__(cls):
        print("__new__ is called")
        return obj

    def __init(self):
        print("__init__ is called")

returnExistedObj()
```

执行结果如下：

```
__new__ is called
12
```

**注意2**：如果我们在`__new__`函数中不返回任何对象，则`__init__`函数也不会被调用。

```python
class notReturnObj(object):
    def __new__(cls):
        print("__new__ is called")

    def __init__(self):
        print("__init__ is called")

print(notReturnObj())
```

```
__new__ is called
None
```

总结：

1. `__init__`不能有返回值
2. `__new__`函数直接上可以返回别的类的实例。
3. 只有在`__new__`返回一个新创建属于该类的实例时当前类的`__init__`才会被调用。



### 3. 用new实现单例模式

https://blog.csdn.net/hiudawn/article/details/80377510

单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。

```python
class A:
    instance = None
    init_flag = False  # 初始化标记

    def __new__(cls, *args, **kwargs):
        if cls.instance is None:
            cls.instance = super().__new__(cls)
        return cls.instance

    def __init__(self):
        if A.init_flag:
            return
        print('执行了初始化方法')
        A.init_flag = True


if __name__ == '__main__':
    a = A()
    b = A()
    print(a)
    print(b)
```



### 4. python 的 对象销毁垃圾回收机制

Python 使用了引用计数这一简单技术来跟踪和回收垃圾。

在 Python 内部记录着所有使用中的对象各有多少引用。

一个内部跟踪变量，称为一个引用计数器。

当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是"立即"的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。

```
a = 40      # 创建对象  <40>
b = a       # 增加引用， <40> 的计数
c = [b]     # 增加引用.  <40> 的计数

del a       # 减少引用 <40> 的计数
b = 100     # 减少引用 <40> 的计数
c[0] = -1   # 减少引用 <40> 的计数
```

### 5. Django

Django 是一个由 Python 编写的一个开放源代码的 Web 应用框架。

使用 Django，只要很少的代码，Python 的程序开发人员就可以轻松地完成一个正式网站所需要的大部分内容，并进一步开发出全功能的 Web 服务 Django 本身基于 MVC 模型，即 Model（模型）+ View（视图）+ Controller（控制器）设计模式，MVC 模式使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。

#### MVC

- 模型（M）- 编写程序应有的功能，负责业务对象与数据库的映射(ORM)。
- 视图（V）- 图形界面，负责与用户的交互(页面)。
- 控制器（C）- 负责转发请求，对请求进行处理。

![截屏2020-12-09 上午12.58.31](/Users/una/newroot/本地图床/截屏2020-12-09 上午12.58.31.png)

MTV

- M 表示模型（Model）：编写程序应有的功能，负责业务对象与数据库的映射(ORM)。
- T 表示模板 (Template)：负责如何把页面(html)展示给用户。
- V 表示视图（View）：负责业务逻辑，并在适当时候调用 Model和 Template。

用户通过浏览器向我们的服务器发起一个请求(request)，这个请求会去访问视图函数：

- a.如果不涉及到数据调用，那么这个时候视图函数直接返回一个模板也就是一个网页给用户。
- b.如果涉及到数据调用，那么视图函数调用模型，模型去数据库查找数据，然后逐级返回。

视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。

#### **创建项目**

https://www.yiibai.com/django/django_creating_project.html

myproject/  

 	manage.py   

​	myproject/  （一个python的包）   

 	   \__init__.py     

​		 settings.py      参数设置 （调试模式，数据库

​		urls.py      

​		wsgi.py 如果需要部署项目在 WSGI 上

开始运行

```shell
python manage.py runserver
```

#### 创建应用程序

```
python manage.py startapp myapp 
```

```powershell
myapp/
   __init__.py 只是为了确保 python 作为包处理此文件夹。
   admin.py 此文件帮助您在管理界面中修改应用程序。
   models.py  这是存储所有的应用程序的模型。
   tests.py 这是单元测试。
   views.py 这是应用程序视图
```

将应用程序设置到项目

```python
INSTALLED_APPS = (
   'django.contrib.admin',
   'django.contrib.auth', # 设置身份认证
   'django.contrib.contenttypes',
   'django.contrib.sessions',
   'django.contrib.messages',
   'django.contrib.staticfiles',
   'myapp',
)
```

#### 管理员	 				 				 				 			

​		Django为管理活动提供随时可以使用的用户界面。我们都知道，管理界面对于一个Web项目是十分重要的。Django根据您的项目模型自动生成管理界面。 

​		管理界面依赖于 django.contrib 模块。若需它工作，需要确保一些模块是否导入在 myproject/settings.py 文件中的INSTALLED_APPS和MIDDLEWARE_CLASSES元组。 

​		对于 INSTALLED_APPS 确保有 - 

```python
INSTALLED_APPS = (
   'django.contrib.admin',
   'django.contrib.auth',
   'django.contrib.contenttypes',
   'django.contrib.sessions',
   'django.contrib.messages',
   'django.contrib.staticfiles',
   'myapp',
)
```

​		对于 MIDDLEWARE_CLASSES 有− 

```python
MIDDLEWARE_CLASSES = (
   'django.contrib.sessions.middleware.SessionMiddleware',
   'django.middleware.common.CommonMiddleware',
   'django.middleware.csrf.CsrfViewMiddleware',
   'django.contrib.auth.middleware.AuthenticationMiddleware',
   'django.contrib.messages.middleware.MessageMiddleware',
   'django.middleware.clickjacking.XFrameOptionsMiddleware',
)
```

shell 启动数据库。syncdb将创建必要的表，或根据您的数据库类型的集合，以及必要的管理界面来运行。 即使你不是一个超级用户，系统会提示创建一个。

```python
python manage.py syncdb 
```

创建超级用户

```
python manage.py createsuperuser 
```

管理界面配置url

```python
"""myproject URL Configuration
The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/1.9/topics/http/urls/ 
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  url(r'^$', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  url(r'^$', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.conf.urls import url, include
    2. Add a URL to urlpatterns:  url(r'^blog/', include('blog.urls'))
"""
from django.conf.urls import url
from django.contrib import admin
urlpatterns = [
    url(r'^admin/', admin.site.urls),
]

```

#### 创建视图与模版

视图功能，或简称"view"，是一个简单的Python函数，它接受一个Web请求，并返回一个Web响应。此响应可以是 Web页的HTML内容，或重定向，或404错误，或XML文档，或图像/片等。例如：使用视图创建页面，请注意需要将一个视图关联到一个URL，并把它看作一个网页。 

在Django中，视图必须在应用程序的 views.py 文件中创建。也可以通过模版返回视图。

用户通过浏览器向我们的服务器发起一个请求(request)，这个请求会去访问视图函数：

- a.如果不涉及到数据调用，那么这个时候视图函数直接返回一个模板也就是一个网页给用户。
- b.如果涉及到数据调用，那么视图函数调用模型，模型去数据库查找数据，然后逐级返回。

​		现在，我们的视图内容如下 − view.py

```
from django.shortcuts import render

def hello(request):
   return render(request, "myapp/template/hello.html", {})
```

​		一个模板文件: myapp/templates/hello.html 

```
from django.http import HttpResponse

def hello(request, number):
   text = "<h1>welcome to my app number %s!</h1>"% number
   return HttpResponse(text) 
```

​		当链接到一个网址，页面会显示作为参数传递的数值。

模版语言 DTL

#### 视图传入变量 	 

​		变量显示如下：{{variable}}. 模板由视图在渲染(render)函数的第三个参数发送的变量来替换变量。让我们改变 hello.html 显示当天的日期 ： 

​		hello.html 

```
<html>   
   <body>
      Hello World!!!<p>Today is {{today}}</p>
   </body>   
</html>
```

​		然后，我们的视图将改变为 - 

```
def hello(request):
   today = datetime.datetime.now().date()
   return render(request, "hello.html", {"today" : today}) 
```

​		现在，我们将得到下面的输出在访问URL /myapp/hello 之后− 

```
Hello World!!!
Today is Sept. 11, 2015 
```

//原文出自【易百教程】，商业转载请联系作者获得授权，非商业转载请保留原文链接：https://www.yiibai.com/django/django_template_system.html  

#### URL映射与重定向

当用户在您的网络应用程序发起一个网页的请求，Django控制器会接管通过url.py文件来寻找相应的视图，然后返回HTML响应或如果没有找到则返回404未找到错误。最重要的是“urlpatterns” 元组。这就是定义URL和视图之间的映射。一个映射的URL模式就像一个元组 − 

```python
from django.conf.urls import patterns, include, url
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
   #Examples
   #url(r'^$', 'myproject.view.home', name = 'home'),
   #url(r'^blog/', include('blog.urls')),

   url(r'^admin', include(admin.site.urls)),
   url(r'^hello/', 'myapp.views.hello', name = 'hello'),
) 
```

重定向：redirect

修改view 

```python
from django.shortcuts import render, redirect
from django.http import HttpResponse
import datetime

# Create your views here.
def hello(request):
   today = datetime.datetime.now().date()
   daysOfWeek = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
   return redirect("https://www.djangoproject.com")
	
def viewArticle(request, articleId):
   """ A view that display an article based on his ID"""
   text = "Displaying article Number : %s" %articleId
   return redirect(viewArticles, year = "2045", month = "02")
	
def viewArticles(request, year, month):
   text = "Displaying articles of : %s/%s"%(year, month)
   return HttpResponse(text) 
```

#### 上下文管理器

全局变量管理器

1. 定义

   放置位置不限

   ```
   def my_name(request):
   return {'name': 'Jack'}
   ```

2. settings.py注册

   ```
   TEMPLATES = [
   ...
   'context_processors': [
   ...
   'firstapp.customer_context.my_name'(http://www.amjmh.com)
   ```

3. 在模版文件中使用

   ```
   <body>
   {{ name }}
   <form action="" method="post">
   ```

   如果同时有上下文管理器, 和上下文数据(context), 他们是按照顺序执行的, 如果这两者都有相同的变量名时 , context生效

#### 用户

**身份认证系统使用了2个app，2个中间件**(setting.py)

INSTALLED_APPS中添加：

* '**django.contrib.auth**'(身份认证系统) ‘
* **django.contrib.contenttypes**’(内容类型系统，它将允许身份认证系统与我们创建的模型相关联,也就是说身份认证系统与我们创建的模型需要通过内容类型系统进行处理)

MIDDLEWARE中添加以下内容：

- SessionMiddleware：session中间件，用来管理请求会话
- AuthenticationMiddleware：身份验证中间件，用来使用户和请求相关联

#### 修改密码

- admin后台管理系统
- python manage.py changepassword 修改
- 通过自定义视图修改

``` python
python manage.py changepassword 用户名
```

```python

def mysql(request):
    template = loader.get_template('app_Mysql/table.html')
    context = {
        'latest_question_list': {'xxx': 123},
    }
    from django.contrib.auth.models import User
    u = User.objects.get(username='zhangsan')
    u.set_password('zhangsan66666')
    u.save()
```

### 6. 装饰器

```python
from functools import wraps

def dec(func):
    @wraps(func)
    def decoratetionfun(*args, **kwargs):
        print("123")
        # func()
        print("apple")

    return decoratetionfun

@dec
def a():
    print("una")

a()
# a()
```

### 7. 开源项目

Django

oh-my-zsh

Hexo

Vue

go.Iris

## 云轴一面

### 1. centos的包管理器（yum）yum的实现原理

https://cloud.tencent.com/developer/article/1419342

yum工作原理

- **yum服务器**

yum服务器提供rpm包及其基本信息、依赖关系的下载

- **yum客户端**

每次`yum install`或者`search`的时候，都会去解析`/etc/yum.repos.d/`下面所有以`.repo`结尾的配置文件，获取yum服务器地址。yum会定期去更新yum服务器上的rpm包清单，下载到本地缓存（默认在`/var/cache/yum/$basearch/$releasever`)。每次调用yum安装的时候，都会去本地缓存查找清单，根据清单里的rpm包描述从而确定安装包的名字、版本号、所需要的依赖等，然后再去yum服务器下载（如果缓存中rpm包就不用下载）