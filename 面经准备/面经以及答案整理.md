

面经总结

# 深信服

![D CHANGED IN A FEW SECONDS](/Users/una/newroot/本地图床/D CHANGED IN A FEW SECONDS.png)

### 1. swift与go的区别

跨平台性：swift 是苹果的御用语言 虽然开源目前很大程度是与微软推出的.NETCore差不多，只支持Ubuntu 还是指定版本的。go目前是真正的跨平台语言，主流的系统和CPU架构都有支持。

语言特性：swift产生比go要晚一点，设计思想与go不同，swift有一点想玩一把编程语言集大成者的意思，几乎把其他现有语言的先进特性都吸收了过来，在此基础上还把编程人员经常诟病或是烦人的地方进行有特性功能扩展（比如协议支持默认实现  对象类可以不实现从协议中继承一部分代码  很多程度上避免了代码重复）。通过这些特性使得原来语言的编程人员很快发现与swift相同或相似的地方，随着深入逐渐发现swift语言特性，学习曲线比较平滑。 但是同时也带来了类似C++的问题，因为swift支持多范式编程，融合了很多特性，实现功能往往有很多种设计或实现方式而且差异很大。所以有时候会出现同样是swift程序员，但是互相不习惯对方的代码，更严重的情况下甚至看不懂。然而真的掌握这么多的设计模式或范式无形中提高的门槛，一定程度上把不同程度上的人群起到分离作用。而且目前没有工业化标准，就是定标准也是很麻烦的事，定的太高能达到的人很少，会出现有标准每人管的现象，如果定的比较低，swift语言特性在大部分时间都是多余的。

swift 是多范式编程语言。可结构化编程struct enum，可面向对象class，可面向协议protocol，可函数式 high-order，pure function。

从数据结构上来看，swift提倡多用struct enum少用class。抽象上提倡protocol-oriented（能用在class上，也能在struct上，比java接口更强大），最重要的，不要忘了function也是非常重要的数据结构，利用high-order可以写出复用性更好的代码，利用pure function写出更健壮的代码。

go的最大优势就是执行速度和开发效率都很出色，而且从语言级别上支持并发。执行速度快是因为go是编译型的静态语言，它在执行速度上比解释型语言具有先天的优势。生产效率高是基于go的语法和结构简明，易学易用。 go出现之前，无论汇编语言、还是动态脚本语言，在执行效率和开发效率上都不能兼备。

### 2. siwft与js的类似与区别

**Swift 是一个「JavaScript 风格的 C#」**

（1）层次结构

* 两者都可以在 **全局** 执行语句和表达式。当然，这并不是什么脚本语言的专利，C语言都可以。相比Java和C#只能在类的方法（或初始化及匿名代码块？）里执行语句要人性化很多。

两者都有相应的 **依赖机制**，但Swift是基于 **文件无关的 Module**（类似于C#那样层次化的命名空间）的；而 JavaScript 是基于 **文件路径** 的。因此对于相同复杂程度的依赖，JavaScript 往往需要更多的 import 关键字（恰好两者关键字都是 import ）。

（2）类型

* Swift 为 **强类型、静态类型**；JavaScript 为 **弱类型、动态类型**

Swift 具有一个可选的 **显式类型** 声明语法，也可依靠类型推理使用 **隐式类型**。

* 两者都有 **类** 语法，但 Swift 除了 Class（引用类型，堆内存）之外还支持 Structure （值类型，栈内存）。

*  继承方面，Swift 支持 **协议**（Protocol）类型（可以声明式多继承）；而 JavaScript 并没有接口类型（只能单继承）

* 数值类型方面，Swift 区分整型（Int 等）和浮点型（Float 等）数值，并且区分有符号和无符号类型；而 JavaScript 只有基于64位浮点型的 Number 类型数值。

* 字符类型方面，Swift区分字符（Character）和字符串（String）；而 JavaScript 中只有字符串。

Swift 支持可空类型（T?）和不可空类型（T!），并且支持空接合运算；JavaScript 只能靠团队约定或逐级检查。

（3）基本语法

* Swift 中，**var** 为变量，**let** 为常量；而 JavaScript 中，**var** 为函数作用域变量，**let** 为块作用域变量，**const** 为常量

两者都有 **可选分号**，Swift 不推荐使用分号，JavaScript 写不写分号的争议较大。

两者都支持 **字符串内插**

* Swift 中 **不论字符还是字符串** 都是双引号（**"**），靠变量类型来逆推表达式类型；
  而 JavaScript 中字符串既可以用双引号（**"**）也可以用单引号（**'**）以及反引号（**`**）（模板字符串）。

（4）**函数**

函数返回值方面，两者都支持表观上的函数 **多返回值**，Swift 靠的是元组语法，JavaScript 靠的是对象/数组解构语法（此处以对象解构为例）。

函数参数方面，两者都支持 **可选参数**。

函数参数方面，两者都支持 **不定项参数**。

（5）**容器**

两者有相似的 **原生容器类型**，Swift 的原生容器有 Array、Set、Dictionary；JavaScript 有Array、Set、WeakSet、Map、WeakMap。(Object不是容器）

两者都支持较为简洁的 **初始化** 语法。

* Swift 支持 **可访问性** 修饰符，对成员可以设置（private、internal、public等）不同的访问级别；
  JavaScript 没有可访问性限制，除了构造特殊闭包外所有成员均可视为 public。

Swift 支持 **扩展方法**，JavaScript 本来就是动态类型可以对原型随便加方法。

### 3. 静态数据动态数据 强类型语言弱类型语言

https://www.zhihu.com/question/19918532

*强类型strongly typed*: 结果角度看，如果一种语言的所有程序都是well behaved——即不可能出现forbidden behaviors，则该语言为strongly typed。直接报错。原因角度看inferred type（推断式语言）在编译时确定此变量类型，不能出现类型转换。

*弱类型weakly typed*: 否则为weakly typed。比如C语言的缓冲区溢出，属于trapped errors，即属于forbidden behaviors..故C是弱类型。可能出现隐式转换。弱语言允许将一块内存看作多种类型。

*静态类型 statically*: 如果在编译时拒绝ill behaved程序，则是statically typed;

*动态类型dynamiclly*: 如果在运行时拒绝ill behaviors, 则是dynamiclly typed。

*Forbidden Behaviours*：语言设计时，可以定义一组 forbidden behaviors. 它必须包括所有untrapped errors, 但可能包含trapped errors.

*Errors ：*

* *trapped errors*。导致程序终止执行，如除0，Java中数组越界访问 

* *untrapped errors*。 出错后继续执行，但可能出现任意行为。如C里的缓冲区溢出、Jump到错误地址

*Well behaved、ill behaved*

- *well behaved*: 如果程序执行不可能出现forbidden behaviors, 则为*well behaved*。
- *ill behaved: 否则为ill behaved...*

无类型： 汇编
弱类型、静态类型 ： C/  C++（混血）
弱类型、动态类型检查： Perl/PHP/js
强类型、静态类型检查 ：Java/C#/swift
强类型、动态类型检查 ：Python, Scheme
静态**显式**类型 ：Java/C
静态隐式类型 ：Ocaml, Haskell

### 4. interface，抽象类与继承

interface是面向对象编程语言中接口操作的关键字，功能是把所需成员组合起来，用来装封一定功能的集合。它好比一个模板，在其中定义了对象必须实现的成员，通过类或结构来实现它。接口不能直接[实例](https://baike.baidu.com/item/实例)化，即ICount ic=new iCount()是错的。接口不能包含成员的任何代码，只定义成员本身。接口成员的具体代码由实现接口的类提供。接口使用interface关键字进行声明

与类相似，接口可以包含方法、属性、索引器和事件作为成员。接口中可以声明属性、方法、事件和类型(Structure)，（但不能声明变量），但是并不能设置这些成员的具体值，也就是说，只能定义，不能给它里面定义的东西赋值。

**声明格式**如下：

[attributes] [modifiers] interface identifier [: base-list] {interface-body} {;}

1、attributes（可选）：附加的定义性信息。

2、modifiers（可选）： 允许使用的修饰符有 new 和四个访问修饰符。分别是：new、public、protected、internal、 private。在一个接口定义中同一修饰符不允许出现多次，new 修饰符只能出现 在嵌套接口中，表示覆盖了继承而来的同名成员。The public, protected, internal, and private 修饰符定义了对接口的访问权限。

3、指示器和事件。

4、identifier：接口名称。

5、base-list（可选）:包含一个或多个显式基接口的列表，接口间由逗号分隔。

6、interface-body：对接口成员的定义。

7、接口可以是命名空间或类的成员，并且可以包含下列成员的签名： 方法、属性、索引器 。

8、一个接口可从一个或多个基接口继承。

C#和Java一个接口可以扩展一个或者多个其他接口。

**接口的成员变量**

接口中的成员变量具有公共性（public）、静态性（static）和最终性（final）。所以修饰符只能是public，因此只能定义常量。接口中的属性都是静态常量，方法都是抽象方法（即没有给出方法具体定义），一个类实现接口后，将继承接口中的所有静态常量。

**实现接口类**

实现多接口的类必须符合3个原则：能为所有的接口提供实现的功能，能遵循重写的所有规则，能保持相同的返回的数据类型。

**接口继承**

接口可以[多继承](https://baike.baidu.com/item/多继承/7705685)接口 因为接口只定义行为 并不包含类别的含义 不指代具体的某类事物 而且 从语义上来说 接口对接口的继承称之为扩展更为合适

接口可以多继承，是因为接口中只有抽象方法，没有静态方法和非常量的属性，只有接口的实现类才会重写接口中方法。因此一个类有多个接口也不会增加JVM的绑定机制和复杂度。

**类继承**

java类继承是单继承：当子类重写父类方法的时候，或者隐藏父类的成员变量以及静态方法的时候，JVM使用不同的绑定规则。如果一个类有多个直接的父类，那么会使绑定规则变得更复杂。为了简化软件的体系结构和绑定机制，java语言禁止多继承。

**接口与抽象类区别**

共同点如下：
1)	都是上层的抽象层。
2)	都不能被实例化
3)	都能包含抽象的方法，这些抽象的方法用于描述类具备的功能，但是不比提供具体的实现。
区别如下：
1)	在抽象类中可以写非抽象的方法，从而避免在子类中重复书写他们，这样可以提高代码的复用性，这是抽象类的优势；接口中只能有抽象的方法。
2)	一个类只能继承一个直接父类，这个父类可以是具体的类也可是抽象类；但是一个类可以实现多个接口。

### 5. Go goroutine 和 channel 

http://wecatch.me/go/posts/go-goroutine-channel-1/#:~:text=%E5%AE%9A%E4%B9%89,%E7%A7%B0%E4%B9%8B%E4%B8%BA%20main%20goroutine%20%E3%80%82&text=%E5%9C%A8%E8%BF%99%E4%B8%AA%E4%BE%8B%E5%AD%90%E4%B8%AD%EF%BC%8C%20go,%E4%B8%A4%E4%B8%AA%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E6%89%A7%E8%A1%8C%E3%80%82

Go 支持两种方式的并发模型: communicating sequential processes(CSP) 和 shared memory multithreading，前者是 goroutine 和 channel 并发模型实现的基础，后者是传统的共享内存的方式，也就是多线程模型。

如何理解 CSP ？简单来说就是通过在不同的 goroutine 之间传递 value 来维护并发的下不同 goroutine 的状态，但是对变量的使用、修改要限制在单一的 goroutine 中。

**Goroutine 定义**

在 Go 中可以并发执行的活动单元称之为 goroutine。当一个 Go 程序启动时，一个执行 main function 的 goroutine 会被创建，称之为 `main goroutine`。创建新的 goroutine 可以使用 go 语句，像这样: go f()，其中 `f` 是一个函数。使用 go 语句开启一个新的 goroutine 之后，go 语句之后的函数调用将在新的 goroutine 中执行，而不会阻塞当前的程序执行。

**Goroutine使用例子**

客户端收服务端请求并且回显，如果不用goroutine，则在两个终端窗口开的客户端只能有一个工作。但是使用go关键字打开goroutine，则可以并发。

**channel 定义**

如果说 goroutine 是并发执行的一个 Go program， channel 就是它们之间的连接通道，它提供了 goroutine 之间相互通信的机制。Channel 是有类型的，channel 中使用的 type 称之为 element type，比如 int 类型的 channel 写作为 `chan int`。

Go 使用 make 内建函数创建 channel。

```go
ch := make(chan int)
```



同 map 一样，一个 channel 引用着 make 创建的底层数据结构上，当把 channel 当做函数参数传递时，实际上是拷贝一份 reference，也就是说函数内部和外部引用的是相同的数据结构，所以在函数内部可以直接修改 channel 的值。同其它 reference type 一样，**channel 的 zero value 是 nil**。

**Channel 是可比较的，如果两个 channel 的类型相同，它们可以彼此相互比较**，当然 channel 也可以和 nil 比较。

**channel 基本操作**

Go 使用 `<-` 操作符来实现 send 和 receive。Send 操作 `<-` 在 channel 右侧，receive 操作 `<-` 在左侧。

```go
ch <- x //send
x = <- ch //receive
<- ch //receive
```

Channel 还支持第三种操作 `close`，如果 channel 被 close，表明 channel 不会再 send 任何值了，如果还继续对 channel 执行 receive 操作，等 channel 中的值消耗完毕之后，之后返回的是对应 element type 的 zero value，如果对 channel 执行 send 操作，将会引起 panic。

```go
close(ch)
```

**Unbuffered channel**

在创建 channel 时可以指定 channel 的容量，如果不指定默认是 0，我们称这种 channel 是 unbuffered channel。

如果在一个 goroutine 中对 unbuffered channel 执行 send 操作将会一直阻塞，直到有另一个不同的 goroutine 对同样的 channel 开始执行 receive 为止，此时通过 channel send 的值会发送到接收端，之后两个 goroutine 才会各自继续执行。

相似地，如果是 receive 操作先执行，也是类似的过程。

**正是因为 unbuffered channel 的这种特性，unbuffered channel 也称之为 synchronous channel**(同步管道)。

```go
package main
import (
    "fmt"
)

func main() {
    c := make(chan int)
    go func(){
        c <- 1
    }
    <-c
    fmt.Println("main goroutine finish ")
}
```

上面的代码展示了利用 unbuffered channel 完成同步的能力，main goroutine 会一直等待直到满足特定条件时才会结束。

### 6. defer，panic 和 recover

https://blog.csdn.net/Jmilk/article/details/107449462

Golang 中常规的错误处理方式是直接 return error 给调用者，再由调用者决定后续的程序逻辑，或捕获、或终止、或恢复。但对于一些无法恢复的错误，返回 error 也没有意义，此时可以考虑使用 panic（惊恐）语句，表示一种自动触发的错误。除了在代码中主动触发 panic，在程序运行的过程中也可能会因为出现某些错误而触发 panic，例如：数组越界。

**panic 会退出当前正在执行的程序**（注意，不只是 Goroutine 协程），但是与 `os.Exit(-1)` 此类 “义无反顾” 的退出不同，panic 的退出更加的 “井然有序”，**panic 会先递归的处理完当前 Goroutine 已经 defer 上去的任务(defer 调用逆序)**，执行完毕后再打印调用栈，最终调用 `exit(-2)` 退出整个进程。

相对的，**recover（恢复）关键字可以恢复 panic 造成的程序终止**，并且 recover 是一个只能在 defer 函数中发挥作用的函数，在其他作用域中调用不会发挥任何作用。

可见，defer、panic、recover 三者的组合可以完成一种灵活的程序流控制。比如：在 defer 中通过 recover 截取 panic，从而达到 try/catch 的效果。

panic 终止了程序，并且是在执行完挂载到 Goroutine 的 defer 之后退出的，同时还打印了错误堆栈。注意，当一个 Goroutine 挂载了多个 defer 的话，其执行顺序是后进先出的，即逆序执行。另外，panic 仅能保证递归当前 Goroutine 下的所有 defer 都会被调用，但不保证其他的 Goroutine。

recover，顾名思义是恢复被 panic 退出的程序流，是 Golang 的 handle panic（异常处理）机制.recover 只在 defer 函数中有效，如果不是在 refer 上下文中调用 recover 会直接返回 nil。

例子：

```go
package main

import (
    "fmt"
    "os"
    "time"
)

func main() {
    defer fmt.Println("defer main") // will this be printed when panic?

    var user = os.Getenv("USER_")

    go func() {
        defer fmt.Println("defer caller")
        func() {
            defer func() {
                fmt.Println("defer here.")
                if err := recover(); err != nil {
                    fmt.Println("recover success.")
                }
            }()

            if user == "" {
                panic("should set user env.")
            }
        }()
    }()

    time.Sleep(1 * time.Second)
    fmt.Println("get result")
}
```

结果：

```
$ go run main.go
defer here.
recover success.
defer caller
get result
defer main
```

### 7. mutex 锁：互斥锁

https://blog.csdn.net/qq_33951180/article/details/72801228#:~:text=%E9%A6%96%E5%85%88%E9%9C%80%E8%A6%81%E6%98%8E%E7%A1%AE%E4%B8%80%E7%82%B9%EF%BC%8C%E4%BA%92,%E8%8E%B7%E5%BE%97%E9%94%81%E6%88%96%E9%87%8A%E6%94%BE%E9%94%81%E3%80%82&text=2%E3%80%81%E4%BD%9C%E7%94%A8%EF%BC%9A%E4%BA%92%E6%96%A5%E9%94%81,%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%92%E6%96%A5%E3%80%82

**概念：**

临界资源：能够被多个线程共享的数据/资源。临界区：对临界资源进行操作的那一段代码

**互斥锁的本质**：
首先需要明确一点，互斥锁实际上是一种变量，在使用互斥锁时，实际上是对这个变量进行置0置1操作并进行判断使得线程能够获得锁或释放锁。

**作用：**互斥锁的作用是对临界区加以保护，以使任意时刻只有一个线程能够执行临界区的代码。实现了多线程之间的互斥。

**使用互斥锁主要有以下几个接口操作：**

```C++
//两种方法对锁进行初始化
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
              const pthread_mutexattr_t *restrict attr);
//互斥锁的销毁
int pthread_mutex_destroy(pthread_mutex_t *mutex);

//获得锁
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);

//释放锁
int pthread_mutex_unlock(pthread_mutex_t *mutex);12345678910111213
```

pthread_mutex_lock：如果此时已经有另一个线程已经获得了锁，那么当前线程调用该函数后就会被挂起等待，直到有另一个线程释放了锁，该线程会被唤醒。
pthread_mutex_trylock：如果此时有另一个贤臣已经获得了锁，那么当前线程调用该函数后会立即返回并返回设置出错码为EBUSY，即它不会使当前线程挂起等待。

**互斥锁的底层实现：**

上边已经提到，mutex的本质是一种变量。假设mutex为1时表示锁是空闲的，此时某个进程如果调用lock函数就可以获得所资源；当mutex为0时表示锁被其他进程占用，如果此时有进程调用lock来获得锁时会被挂起等待。

```C++
lock:
	if(mutex > 0){
		mutex = 0;
		return 0;
	}else{挂起等待}
	goto lock
unlock:
	mutex += 1;
	唤醒线程
	return 0;
```

**死锁**

指在一组进程中的各个进程均占有不会释放的资源，但因互相申请被其他进程所占用不会释放的资源而处于的一种永久等待状态。可能由系统资源不足，申请锁的顺序不当引起。

**死锁产生的条件**
1、互斥属性：即每次只能有一个线程占用资源。
2、请求与保持：即已经申请到锁资源的线程可以继续申请。在这种情况下，一个线程也可以产生死锁情况，即抱着锁找锁。
3、不可剥夺：线程已经得到所资源，在没有自己主动释放之前，不能被强行剥夺。
4、循环等待：多个线程形成环路等待，每个线程都在等待相邻线程的锁资源。

**死锁的避免：**
1、既然死锁的产生是由于使用了锁，那么在能不使用锁的情况下就尽量不使用，如果有多种方案都能实现，那么尽量不选用带锁的这种方案
2、尽量避免同时获得多把锁，如果有必要，就要保证获得锁的顺序相同

### 8. 互斥锁、条件锁、读写锁以及自旋锁

https://www.zhihu.com/question/66733477

自旋锁   while while while 地检查是否能够加锁，浪费 CPU 做无用功。

```
while(没抢到锁){
				keep try 
}
```

互斥锁

为了实现「锁的状态发生改变时再唤醒」就需要把锁也交给操作系统管理。 互斥器的加锁操作通常都需要涉及到上下文切换，操作花销也就会比自旋锁要大。

```
if(mutex > 0){
		mutex = 0;
		return 0;
	}else{挂起等待}
	goto lock
```

条件锁

不是while等待抽象资源是否可用（操作系统控制），而是用事物逻辑控制。条件锁指条件变量，它本身不是锁，而是一种线程通信机制，与互斥量一起使用。

只要某个被锁的条件不发生变化，while循环就没必要进行加锁，判断，条件不成立，解锁的过程。

条件锁的意义是在于通过手写的事物逻辑判断什么时候结束等待。一般来说先解锁互斥量，再解锁条件变量。（因为解锁了条件变量可能让多个等待的条件变量被唤醒了）

使用条件变量，就可以让甲每取出一个任务就发一个通知，然后操作系统自动转发通知给乙（所谓“转发通知”，实质上是，平常乙执行“等待条件变量”系统调用、然后因条件得不到满足而被操作系统自动挂起；等条件满足了，操作系统才会让其继续执行）。

```
while(某个被锁保护条件是否达成){
				解锁等待通知唤醒再加锁（用于收发通知的条件，互斥量）
}


```

while而不使用if的原因：

1. 避免群惊
2. 避免线程虚假唤醒。即没有pthread_cond_signal就解除了阻塞

读写锁

由上述锁完成

### 9. ps top netstat ln 命令

**ps:**

Process Status.ps命令用来列出系统中当前运行的那些进程。ps命令列出的是当前那些进程的快照，就是执行ps命令的那个时刻的那些进程，如果想要动态的显示进程信息，就可以使用top命令。

**netstat**

Netstat是在内核中访问网络连接状态及其相关信息的程序，它能提供TCP连接，TCP和UDP监听，进程内存管理的相关报告。

Netstat是控制台命令,是一个监控TCP/IP网络的非常有用的工具，它可以显示路由表、实际的网络连接以及每一个网络接口设备的状态信息。Netstat用于显示与IP、TCP、UDP和ICMP协议相关的统计数据，一般用于检验本机各端口的网络连接情况。	

**netstat**命令的功能是显示网络连接、路由表和网络接口信息，可以让用户得知有哪些网络连接正在运作。 [1] 使用时如果不带参数，**netstat**显示活动的 TCP 连接。

**ln:**

它的功能是为某一个文件在另外一个位置建立一个同步的链接.当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。

### 10. ln- 软连接硬连接

ln的链接又分软链接和硬链接两种

* 软链接就是ln –s 源文件 目标文件，它只会在你选定的位置上生成一个文件的镜像，不会占用磁盘空间

* 硬链接 ln 源文件 目标文件，没有参数-s， 它会在你选定的位置上生成一个和源文件大小相同的文件，无论是软链接还是硬链接，文件都保持同步变化。

区别：

1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式

2.软链接可以 跨文件系统 ，硬链接不可以

3.软链接可以对一个不存在的文件名进行链接

4.软链接可以对目录进行链接

5.硬链接，以文件副本的形式存在。但不占用实际空间。

6.不允许给目录创建硬链接

7.硬链接只有在同一个文件系统中才能创建

### 11. 排序

https://www.cnblogs.com/onepixel/p/7674659.html

排序分类

- **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O(nlogn)，因此也称为非线性时间比较类排序。
- **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

* 比较类

  * 交换排序
    * 冒泡排序 					
    * 快速排序

  * 插入排序
    * 简单插入排序
    * 希尔排序

  * 选择排序
    * 简单选择排序
    * 堆排序
  * 归并排序
    * 二路归并
    * 多路归并

* 非比较类

  * 计数排序
  * 桶排序
  * 基数排序

相关概念

- **稳定**：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
- **不稳定**：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
- **时间复杂度**：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
- **空间复杂度：**是指算法在计算机

#### 冒泡

时间平均 (n^2) 时间最差(n^2) 时间最好(n) 空间(1) 稳定

冒泡排序是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。 

```python
for i in range(len(listOfNum)):
	ifSwap = 0
	for j in ranege(i):
		if listOfNum[j] > listOfNum[j+1]:
			swap(listOfNum[j] , listOfNum[j+1])
			ifSwap = 1
	if ifSwap == 0:
		return
```

#### 快速排序

最好： nlog2n 最差 n^2 平均 nlog2n 空间nlog2n 不稳定

快速排序的基本思想：通过一趟排序将待排记录分隔成独立的两部分，其中一部分记录的关键字均比另一部分的关键字小，则可分别对这两部分记录继续进行排序，以达到整个序列有序。

```python
class Solution:
    def participite(self, listSort, left, right):
        girl = left+1
        standard = listSort[left]
        for boy in range(left+1, right+1):
            if listSort[boy] <= standard:
                listSort[boy], listSort[girl] = listSort[girl], listSort[boy]
                girl += 1
        listSort[left], listSort[girl-1] = listSort[girl-1], listSort[left]
        return girl-1

    def quikSort(self, listSort, left, right):
        if left >= right:
            return
        pi = self.participite(listSort, left, right)

        self.quikSort(listSort, left, pi-1)
        self.quikSort(listSort, pi+1, right)

        return listSort
      
test = Solution()
listSort = [4, 2, 3, 5, 8, 1, 9, 0, -3]
print(test.quikSort(listSort, 0, 8))
```

计算复杂度

https://www.zhihu.com/question/22393997

# 深信服 python 面经准备



### 1. [链表](https://www.nowcoder.com/jump/super-jump/word?word=链表)和数组的区别，如何用python实现。

* 数组：相同数据类型的元素按一定顺序排列的集合；数组的存储区间是连续的，占用内存比较大，故空间复杂的很大。数组的特点是：查询简单，增加和删除困难；因为数组的内存是连续的，想要访问那个元素，直接从数组的首地址向后偏移就可以访问到了。从**栈分配**的。

* 链表:链表存储区间离散，占用内存比较宽松，故空间复杂度很小，但时间复杂度很大，达O（N）。链表的特点是：查询相对于数组困难，增加和删除容易。链表是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列结点（链表中每一个元素称为结点）组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 链表的空间是从**堆中分配**的。

python 

```python
class Node(object):
    """define the node"""

    def __init__(self, item):
        # save item
        self.item = item
        # next
        self.next = None
```

### 2. \__init__ 和 \___new___的区别

https://blog.csdn.net/luoweifu/article/details/82732313

**new**为对象分配空间，是内置的静态方法，**new**在内存中为对象分配了空间也返回了对象的引用，**init**获得了这个引用才初始化这个实例。

`__new__`所接收的第一个参数是`cls`，而`__init__`所接收的第一个参数是`self`。这是因为当我们调用`__new__`的时候，该类的实例还并不存在（也就是`self`所引用的对象还不存在），所以需要接收一个类作为参数，从而产生一个实例。而当我们调用`__init__`的时候，实例已经存在，因此`__init__`接受`self`作为第一个参数并对该实例进行必要的初始化操作。这也意味着`__init__`是在`__new__`之后被调用的。`__new__`作为构造器，起创建一个类实例的作用。而`__init__`作为初始化器，起初始化一个已被创建的实例的作用。

`__new__`函数首先被调用，构造了一个`newStyleClass`的实例，接着`__init__`函数在`__new__`函数返回一个实例的时候被调用，并且这个实例作为`self`参数被传入了`__init__`函数。

```python
class A(object):  # -> don't forget the object specified as base

    def __new__(cls):
        print "A.__new__ called"
        return super(A, cls).__new__(cls)

    def __init__(self):
        print "A.__init__ called"

A()
```

```
A.__new__ called
A.__init__ called
```

__new__ 是在我们调用类名进行实例化时自动调用的，__init__ 是在这个类的每一次实例化对象之后调用的

**注意1**：如果`__new__`函数返回一个已经存在的实例（不论是哪个类的），`__init__`不会被调用。如下面代码所示：

```python
obj = 12 
# obj can be an object from any class, even object.__new__(object)

class returnExistedObj(object):
    def __new__(cls):
        print("__new__ is called")
        return obj

    def __init(self):
        print("__init__ is called")

returnExistedObj()
```

执行结果如下：

```
__new__ is called
12
```

**注意2**：如果我们在`__new__`函数中不返回任何对象，则`__init__`函数也不会被调用。

```python
class notReturnObj(object):
    def __new__(cls):
        print("__new__ is called")

    def __init__(self):
        print("__init__ is called")

print(notReturnObj())
```

```
__new__ is called
None
```

总结：

1. `__init__`不能有返回值
2. `__new__`函数直接上可以返回别的类的实例。
3. 只有在`__new__`返回一个新创建属于该类的实例时当前类的`__init__`才会被调用。



### 3. 用new实现单例模式

https://blog.csdn.net/hiudawn/article/details/80377510

单例模式（Singleton）的目的是为了保证在一个进程中，某个类有且仅有一个实例。

```python
class A:
    instance = None
    init_flag = False  # 初始化标记

    def __new__(cls, *args, **kwargs):
        if cls.instance is None:
            cls.instance = super().__new__(cls)
        return cls.instance

    def __init__(self):
        if A.init_flag:
            return
        print('执行了初始化方法')
        A.init_flag = True


if __name__ == '__main__':
    a = A()
    b = A()
    print(a)
    print(b)
```



### 4. python 的 对象销毁垃圾回收机制

Python 使用了引用计数这一简单技术来跟踪和回收垃圾。

在 Python 内部记录着所有使用中的对象各有多少引用。

一个内部跟踪变量，称为一个引用计数器。

当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是"立即"的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。

```
a = 40      # 创建对象  <40>
b = a       # 增加引用， <40> 的计数
c = [b]     # 增加引用.  <40> 的计数

del a       # 减少引用 <40> 的计数
b = 100     # 减少引用 <40> 的计数
c[0] = -1   # 减少引用 <40> 的计数
```

- 对象别名被显示销毁 del
- 对象别名被赋予新的对象
- 一个对象离开他的作用域
- 对象所在的容器被销毁或者是从容器中删除对象

缺点：循环引用

**标记清除解决循环**

- A）标记阶段，遍历所有的对象，如果是可达的（reachable），也就是还有对象引用它，那么就标记该对象为可达；
- B）清除阶段，再次遍历对象，如果发现某个对象没有标记为可达，则就将其回收。

**分代回收**Generational Collection threshold0, threshold1, threshold2

**“分代回收”(Generational Collection)**以空间换时间的方法提高垃圾回收效率。

分代回收是基于这样的一个统计事实，对于程序，存在一定比例的内存块的生存周期比较短；而剩下的内存块，生存周期会比较长，甚至会从程序开始一直持续到程序结束。生存期较短对象的比例通常在 80%～90% 之间，这种思想简单点说就是：对象存在时间越长，越可能不是垃圾，应该越少去收集。这样在执行标记-清除算法时可以有效减小遍历的对象数，从而提高垃圾回收的速度。

每一个新生对象在generation zero中，如果它在一轮gc扫描中活了下来，那么它将被移至generation++

某一世代中被分配的对象与被释放的对象之差达到某一阈值的时候，就会触发gc对某一世代的扫描。值得注意的是当某一世代的扫描被触发的时候，比该世代年轻的世代也会被扫描。也就是说如果世代2的gc扫描被触发了，那么世代0,世代1也将被扫描，如果世代1的gc扫描被触发，世代0也会被扫描。

该阈值可以通过下面两个函数查看和调整:

```python
gc.get_threshold() # (threshold0, threshold1, threshold2).
gc.set_threshold(threshold0[, threshold1[, threshold2]])
```

下面对set_threshold()中的三个参数threshold0, threshold1, threshold2进行介绍。gc会记录自从上次收集以来新分配的对象数量与释放的对象数量，当两者之差超过threshold0的值时，gc的扫描就会启动，初始的时候只有世代0被检查。如果自从世代1最近一次被检查以来，世代0被检查超过threshold1次，那么对世代1的检查将被触发。相同的，如果自从世代2最近一次被检查以来，世代1被检查超过threshold2次，那么对世代2的检查将被触发。get_threshold()是获取三者的值，默认值为(700,10,10).

**回收内存泄漏**

如果没有禁用垃圾回收，那么Python中的内存泄露有两种情况：要么是对象被生命周期更长的对象所引用，比如global作用域对象；要么是循环引用中存在__del__（如果定义了__del__函数，那么在循环引用中Python解释器无法判断析构对象的顺序，因此就不错处理。）

检测：如果发现内存使用率超过设置的阈值则立即报警。

解决：在第一种情况下，只要在适当的时机解除引用就可以了；在第二种情况下，要么不再使用__del__函数，换一种实现方式，要么解决循环引用。

定位：

使用gc module、**objgraph**可以定位内存泄露，定位之后，解决很简单

使用gc module的DEBUG选项可以很方便的定位循环引用，解除循环引用的办法要么是手动解除，要么是使用weakref

### 5. Django

Django 是一个由 Python 编写的一个开放源代码的 Web 应用框架。

使用 Django，只要很少的代码，Python 的程序开发人员就可以轻松地完成一个正式网站所需要的大部分内容，并进一步开发出全功能的 Web 服务 Django 本身基于 MVC 模型，即 Model（模型）+ View（视图）+ Controller（控制器）设计模式，MVC 模式使后续对程序的修改和扩展简化，并且使程序某一部分的重复利用成为可能。

#### MVC

- 模型（M）- 编写程序应有的功能，负责业务对象与数据库的映射(ORM)。
- 视图（V）- 图形界面，负责与用户的交互(页面)。
- 控制器（C）- 负责转发请求，对请求进行处理。

![截屏2020-12-09 上午12.58.31](/Users/una/newroot/本地图床/截屏2020-12-09 上午12.58.31.png)

MTV

- M 表示模型（Model）：编写程序应有的功能，负责业务对象与数据库的映射(ORM)。
- T 表示模板 (Template)：负责如何把页面(html)展示给用户。
- V 表示视图（View）：负责业务逻辑，并在适当时候调用 Model和 Template。

用户通过浏览器向我们的服务器发起一个请求(request)，这个请求会去访问视图函数：

- a.如果不涉及到数据调用，那么这个时候视图函数直接返回一个模板也就是一个网页给用户。
- b.如果涉及到数据调用，那么视图函数调用模型，模型去数据库查找数据，然后逐级返回。

视图函数把返回的数据填充到模板中空格中，最后返回网页给用户。

#### **创建项目**

https://www.yiibai.com/django/django_creating_project.html

myproject/  

 	manage.py   

​	myproject/  （一个python的包）   

 	   \__init__.py     

​		 settings.py      参数设置 （调试模式，数据库

​		urls.py      

​		wsgi.py 如果需要部署项目在 WSGI 上

开始运行

```shell
python manage.py runserver
```

#### 创建应用程序

```
python manage.py startapp myapp 
```

```powershell
myapp/
   __init__.py 只是为了确保 python 作为包处理此文件夹。
   admin.py 此文件帮助您在管理界面中修改应用程序。
   models.py  这是存储所有的应用程序的模型。
   tests.py 这是单元测试。
   views.py 这是应用程序视图
```

将应用程序设置到项目

```python
INSTALLED_APPS = (
   'django.contrib.admin',
   'django.contrib.auth', # 设置身份认证
   'django.contrib.contenttypes',
   'django.contrib.sessions',
   'django.contrib.messages',
   'django.contrib.staticfiles',
   'myapp',
)
```

#### 管理员	 				 				 				 			

​		Django为管理活动提供随时可以使用的用户界面。我们都知道，管理界面对于一个Web项目是十分重要的。Django根据您的项目模型自动生成管理界面。 

​		管理界面依赖于 django.contrib 模块。若需它工作，需要确保一些模块是否导入在 myproject/settings.py 文件中的INSTALLED_APPS和MIDDLEWARE_CLASSES元组。 

​		对于 INSTALLED_APPS 确保有 - 

```python
INSTALLED_APPS = (
   'django.contrib.admin',
   'django.contrib.auth',
   'django.contrib.contenttypes',
   'django.contrib.sessions',
   'django.contrib.messages',
   'django.contrib.staticfiles',
   'myapp',
)
```

​		对于 MIDDLEWARE_CLASSES 有− 

```python
MIDDLEWARE_CLASSES = (
   'django.contrib.sessions.middleware.SessionMiddleware',
   'django.middleware.common.CommonMiddleware',
   'django.middleware.csrf.CsrfViewMiddleware',
   'django.contrib.auth.middleware.AuthenticationMiddleware',
   'django.contrib.messages.middleware.MessageMiddleware',
   'django.middleware.clickjacking.XFrameOptionsMiddleware',
)
```

shell 启动数据库。syncdb将创建必要的表，或根据您的数据库类型的集合，以及必要的管理界面来运行。 即使你不是一个超级用户，系统会提示创建一个。

```python
python manage.py syncdb 
```

创建超级用户

```
python manage.py createsuperuser 
```

管理界面配置url

```python
"""myproject URL Configuration
The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/1.9/topics/http/urls/ 
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  url(r'^$', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  url(r'^$', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.conf.urls import url, include
    2. Add a URL to urlpatterns:  url(r'^blog/', include('blog.urls'))
"""
from django.conf.urls import url
from django.contrib import admin
urlpatterns = [
    url(r'^admin/', admin.site.urls),
]

```

#### 创建视图与模版

视图功能，或简称"view"，是一个简单的Python函数，它接受一个Web请求，并返回一个Web响应。此响应可以是 Web页的HTML内容，或重定向，或404错误，或XML文档，或图像/片等。例如：使用视图创建页面，请注意需要将一个视图关联到一个URL，并把它看作一个网页。 

在Django中，视图必须在应用程序的 views.py 文件中创建。也可以通过模版返回视图。

用户通过浏览器向我们的服务器发起一个请求(request)，这个请求会去访问视图函数：

- a.如果不涉及到数据调用，那么这个时候视图函数直接返回一个模板也就是一个网页给用户。
- b.如果涉及到数据调用，那么视图函数调用模型，模型去数据库查找数据，然后逐级返回。

​		现在，我们的视图内容如下 − view.py

```
from django.shortcuts import render

def hello(request):
   return render(request, "myapp/template/hello.html", {})
```

​		一个模板文件: myapp/templates/hello.html 

```
from django.http import HttpResponse

def hello(request, number):
   text = "<h1>welcome to my app number %s!</h1>"% number
   return HttpResponse(text) 
```

​		当链接到一个网址，页面会显示作为参数传递的数值。

模版语言 DTL

#### 视图传入变量 	 

​		变量显示如下：{{variable}}. 模板由视图在渲染(render)函数的第三个参数发送的变量来替换变量。让我们改变 hello.html 显示当天的日期 ： 

​		hello.html 

```
<html>   
   <body>
      Hello World!!!<p>Today is {{today}}</p>
   </body>   
</html>
```

​		然后，我们的视图将改变为 - 

```
def hello(request):
   today = datetime.datetime.now().date()
   return render(request, "hello.html", {"today" : today}) 
```

​		现在，我们将得到下面的输出在访问URL /myapp/hello 之后− 

```
Hello World!!!
Today is Sept. 11, 2015 
```

//原文出自【易百教程】，商业转载请联系作者获得授权，非商业转载请保留原文链接：https://www.yiibai.com/django/django_template_system.html  

#### URL映射与重定向

当用户在您的网络应用程序发起一个网页的请求，Django控制器会接管通过url.py文件来寻找相应的视图，然后返回HTML响应或如果没有找到则返回404未找到错误。最重要的是“urlpatterns” 元组。这就是定义URL和视图之间的映射。一个映射的URL模式就像一个元组 − 

```python
from django.conf.urls import patterns, include, url
from django.contrib import admin
admin.autodiscover()

urlpatterns = patterns('',
   #Examples
   #url(r'^$', 'myproject.view.home', name = 'home'),
   #url(r'^blog/', include('blog.urls')),

   url(r'^admin', include(admin.site.urls)),
   url(r'^hello/', 'myapp.views.hello', name = 'hello'),
) 
```

重定向：redirect

修改view 

```python
from django.shortcuts import render, redirect
from django.http import HttpResponse
import datetime

# Create your views here.
def hello(request):
   today = datetime.datetime.now().date()
   daysOfWeek = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun']
   return redirect("https://www.djangoproject.com")
	
def viewArticle(request, articleId):
   """ A view that display an article based on his ID"""
   text = "Displaying article Number : %s" %articleId
   return redirect(viewArticles, year = "2045", month = "02")
	
def viewArticles(request, year, month):
   text = "Displaying articles of : %s/%s"%(year, month)
   return HttpResponse(text) 
```

#### 上下文管理器

全局变量管理器

1. 定义

   放置位置不限

   ```
   def my_name(request):
   return {'name': 'Jack'}
   ```

2. settings.py注册

   ```
   TEMPLATES = [
   ...
   'context_processors': [
   ...
   'firstapp.customer_context.my_name'(http://www.amjmh.com)
   ```

3. 在模版文件中使用

   ```
   <body>
   {{ name }}
   <form action="" method="post">
   ```

   如果同时有上下文管理器, 和上下文数据(context), 他们是按照顺序执行的, 如果这两者都有相同的变量名时 , context生效

#### 用户

**身份认证系统使用了2个app，2个中间件**(setting.py)

INSTALLED_APPS中添加：

* '**django.contrib.auth**'(身份认证系统) ‘
* **django.contrib.contenttypes**’(内容类型系统，它将允许身份认证系统与我们创建的模型相关联,也就是说身份认证系统与我们创建的模型需要通过内容类型系统进行处理)

MIDDLEWARE中添加以下内容：

- SessionMiddleware：session中间件，用来管理请求会话
- AuthenticationMiddleware：身份验证中间件，用来使用户和请求相关联

#### 修改密码

- admin后台管理系统
- python manage.py changepassword 修改
- 通过自定义视图修改

``` python
python manage.py changepassword 用户名
```

```python

def mysql(request):
    template = loader.get_template('app_Mysql/table.html')
    context = {
        'latest_question_list': {'xxx': 123},
    }
    from django.contrib.auth.models import User
    u = User.objects.get(username='zhangsan')
    u.set_password('zhangsan66666')
    u.save()
```

### 6. 装饰器

```python
from functools import wraps

def dec(func):
    @wraps(func)
    def decoratetionfun(*args, **kwargs):
        print("123")
        # func()
        print("apple")

    return decoratetionfun

@dec
def a():
    print("una")

a()
# a()
```

### 7. 开源项目

Django

oh-my-zsh

Hexo

Vue

go.Iris

### 8. 内存分类

**内存的分类标准——三分类**
　　这里，在一些资料中是这样定义C++内存分配的，可编程内存在基本上分为这样的几大部分：***\*静态区、堆区、栈区\****。他们的功能不同，对他们使用方式也就不同。
**（1）静态（全局）存储区——static：**内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在。它主要存放***\*静态数据、全局数据和常量\****。也是程序结束后，由操作系统释放。
**（2）栈区——stack：**在执行函数时，***\*函数参数，局部变量（包括const局部变量），函数调用后返回的地址\****都在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。
**（3）堆区——heap：**亦称***\*动态内存分配\****。程序在运行的时候用***\*malloc或new申请\****任意大小的内存，程序员自己负责在适当的时候用free或 delete释放内存。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉，否则，我们认为发生了内存泄漏现象。

### 9. 元类

因此，元类就是创建类这种对象的东西。 type就是Python的内建元类。

str是用来创建字符串对象的类，而int是用来创建整数对象的类。type就是创建类对象的类。

### 10. 协程

**协程是一种用户态的轻量级线程，又称微线程。**

单说协程在执行某个子程序(函数)时，可以指定或者随机地中断，然后去执行其他的子程序(函数)，在合适的时候再返回到中断子程序停止时的状态继续执行。听起像生成器的特性，实际上协程也是基于生成器的。所以协程是通过程序自身的控制，去切换不同任务，实现并发的效果。也就是协程是单线程执行，没有多线程由CPU调度时线程切换的开销，所以效率较高。

# 云轴一面

### 1. centos的包管理器（yum）yum的实现原理

https://cloud.tencent.com/developer/article/1419342

yum工作原理

- **yum服务器**

yum服务器提供rpm包及其基本信息、依赖关系的下载

- **yum客户端**

每次`yum install`或者`search`的时候，都会去解析`/etc/yum.repos.d/`下面所有以`.repo`结尾的配置文件，获取yum服务器地址。yum会定期去更新yum服务器上的rpm包清单，下载到本地缓存（默认在`/var/cache/yum/$basearch/$releasever`)。每次调用yum安装的时候，都会去本地缓存查找清单，根据清单里的rpm包描述从而确定安装包的名字、版本号、所需要的依赖等，然后再去yum服务器下载（如果缓存中rpm包就不用下载）

# 深信服 一面

1. python优势劣势 python有指针吗
2. python new init 区别
3. 单例 进程中和系统中分别怎么实现（提醒系统文件锁

4. assert关键字和if区别（没回答出来

5. try except finally

6. 字典的底层实现

7. 内存管理删除： 计数器-标志-gc

8. yield关键字

9. 装饰器， 返回类型

10. gil锁 （没回答出来

11. linux python怎么调库（

12. 问项目：个人邮箱；个人网站搭建

13. 邮箱发送使用协议-访问网站使用协议

14. 用过什么开源项目，对开源的看法（优缺点

15. 数据结构 红黑树（红和黑的意义），B树，平衡树区别（建议我看234树

16. Diji 算法，深度还是广度？ （只记得用动态规划写。遂问我贪心和动态规划区别，为啥不是贪心。这个问题答得不好。

    

总结：一接电话特别惊讶我是女的 = 口 =。前半段答得不错，就开始深度遍历技能树了。后半段也没啥难度，就是数据结构部分答得不太好，我就有点慌了。总体还好。最后问他有什么建议，他说你记住，技术都是为了工程服务的，一味追求技术没意义。我有点懵。后来想了想，可能是因为我问的是“你对我的未来有啥建议吧”。

### 1. assert

Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。

断言可以在条件不满足程序运行的情况下直接返回错误，而不必等待程序运行后出现崩溃的情况，例如我们的代码只能在 Linux 系统下运行，可以先判断当前系统是否符合条件。

语法格式如下：

```python
assert expression等价于：
```

```python
if not expression:
    raise AssertionError
```

### 2. Global Interpreter Lock 全局解释器锁 GIL

是[计算机程序设计语言](https://zh.wikipedia.org/wiki/计算机程序设计语言)[解释器](https://zh.wikipedia.org/wiki/解释器)用于[同步](https://zh.wikipedia.org/wiki/同步)[线程](https://zh.wikipedia.org/wiki/线程)的一种机制，它使得任何时刻仅有一个线程在执行。[[1\]](https://zh.wikipedia.org/wiki/全局解释器锁#cite_note-1)即便在[多核心处理器](https://zh.wikipedia.org/wiki/多核心處理器)上，使用 GIL 的解释器也只允许同一时间执行一个线程。常见的使用 GIL 的解释器有[CPython](https://zh.wikipedia.org/wiki/CPython)与[Ruby MRI](https://zh.wikipedia.org/wiki/Ruby)。

CPython的线程是[操作系统](https://zh.wikipedia.org/wiki/操作系统)的原生线程。在[Linux](https://zh.wikipedia.org/wiki/Linux)上为pthread，在[Windows](https://zh.wikipedia.org/wiki/Windows)上为Win thread，完全由操作系统调度线程的执行。一个Python解释器进程内有一个主线程，以及多个用户程序的执行线程。即便使用[多核心CPU](https://zh.wikipedia.org/wiki/多核心CPU)平台，由于GIL的存在，也将禁止多线程的并行执行。

Python为了能利用多核多线程的的优势，但又要保证线程之间数据完整性和状态同步，就采用了最简单的加锁的方式（所以说Python的GIL是设计之初一时偷懒造成的！）。Python库的开发者们接受了这个设定，即默认Python是thread-safe，所以开始大量依赖这个特性，无需在实现时考虑额外的内存锁和同步操作。但是GIL的设计有时会显得笨拙低效，但是此时由于内置库和第三方库已经对GIL形成了牢不可破的依赖，想改革GIL反而变得困难了（晕！）。所以目前的现状就是，Python的多线程在多核CPU上，只对于IO密集型计算产生正面效果；而当有至少有一个CPU密集型线程存在，那么多线程效率会由于GIL而大幅下降。

一个防止多线程并发执行机器码的一个Mutex，乍一看就是个BUG般存在的全局锁嘛！

### 3. Dijkstra

动态规划

广度优先

### 4. 2-3-4 树

2-3-4 树是可以用做[字典](https://zh.wikipedia.org/wiki/字典_(資料結構))的一种自平衡[数据结构](https://zh.wikipedia.org/wiki/数据结构)。它可以在logn，这里的 *n* 是树中元素的数目。每个元素必须大于或等于它左边的和它的左子树中的任何其他元素

### 5. B树B+树区别

如图所示，区别有以下两点：

1. B+树中只有叶子节点会带有*指向记录的指针*（ROWID），而B树则所有节点都带有，在内部节点出现的索引项不会再出现在叶子节点中。

2. B+树中所有叶子节点都是通过指针连接在一起，而B树不会。

B+树的优点：

1. 非叶子节点不会带上ROWID，这样，一个块中可以容纳更多的索引项，一是可以降低树的高度。二是一个内部节点可以定位更多的叶子节点。

2. 叶子节点之间通过指针来连接，范围扫描将十分简单，而对于B树来说，则需要在叶子节点和内部节点不停的往返移动。 

B树的优点：

对于在内部节点的数据，可直接得到，不必根据叶子节点来定位。

# 云轴二面

1. 未来发展方向
2. 计算机网络 交换机 选路协议有哪些。cash buffer区别。网络结构
3. 计算机组成 那些存储 cpu组成，存储器的类别，寻址。
4. 数据库 mongodb和sql的区别
5. python Static修饰器 

### 1. 可执行文件怎么调试：gdb

### 2. shell脚本 / shell

Shell Script ，Shell脚本与Windows/Dos下的[批处理](https://baike.baidu.com/item/批处理/1448600)相似，也就是用各类命令预先放入到一个文件中，方便一次性执行的一个[程序文件](https://baike.baidu.com/item/程序文件/10510952)，主要是方便管理员进行设置或者管理用的

shell脚本语言

首先条线一个集中的地方，比如我自己在桌面上创建一个sa的文件夹，然后在这个文件夹里面放上自己经常连接的服务器的连接命令做成一个脚本类似名字叫

ssh-redis

```
#!/bin/sh
ssh piperck@115.28.39.64 -p 22
```

做一个shell脚本，里面放上想要ssh的地址。然后把这个sa文件夹设置到环境变量中，使得可以在terminal的任意地方调用到他们。

因为我自己使用的zsh所以在我的.zshrc里面设置上这个文件夹的路径

```
export PATH="/Users/piperck/Desktop/tools/sa:$PATH"
```

然后重新开个shell 就可以在任何地方输入ssh-redis方便的登陆到目标服务器上面了。

 



# 网易雷火前端准备

### 1. 如何实现垂直居中、水平居中？ 

```html
 <style>
 9     .content{
10         background: orange;
11         position: absolute;
12         top: 50%;
13         left: 50%;
14         transform: translate( -50%, -50%);
15     }
16     </style>
 <style>
 9     .center-vertical{
10         width: 100px;
11         height: 100px;
12         background: orange;
13         position: absolute;
14         top: 0;
15         left: 0;
16         right: 0;
17         bottom: 0;
18         margin: auto;
19     }
20     </style>
```

### 2. 如何解决跨域问题？

https://www.cnblogs.com/ysocean/p/9380551.html

### 同源策略

同源策略它是由 Netscape 提出的一个安全策略，它是浏览器最核心也是最基本的安全功能，如果缺少同源策略，则浏览器的正常功能可能都会受到影响，现在所有支持JavaScript的浏览器都会使用这个策略。

　　所谓同源指的是：

　　**协议、域名、端口号都相同，只要有一个不相同，那么都是非同源。**

**同源策略限制的情况：**

　　1、Cookie、LocalStorage 和 IndexDB 无法读取

　　2、DOM 和 Js对象无法获得

　　3、AJAX 请求不能发送

　　注意：对于像 img、iframe、script 等标签的 src 属性是特例，它们是可以访问非同源网站的资源的。

跨域问题：非同源的项目相互访问

A 要 访问 B， 两者端口不一样，可以在A中通过jsp文件中的ajax访问B

```jsp
<script type="text/javascript">
14     $(document).ready(function(){
15         $.ajax({
16             type:"get",
17             async:false,
18             url:"http://localhost:8080/JavaWeb01/getPassWordByUserNameServlet?userName=Tom",
19             dataType:"json",
20             success:function (data) {
21                 alert(data['passWord']);
22             },
23             error:function () {
24                 alert("error");
25             }
26 
27         });
28     })
29 
30 </script>
```

B中创建一个getPassWordByUserNameServlet 请求的 Servlet

```java
package com.ys.servlet;

import com.alibaba.fastjson.JSONObject;

import javax.servlet.ServletException;
import javax.servlet.annotation.WebServlet;
import javax.servlet.http.HttpServlet;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * Create by YSOcean
 */
@WebServlet("/getPassWordByUserNameServlet")
public class UserServlet extends HttpServlet{
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String userName = req.getParameter("userName");
        String passWord = null;
        if(userName != null){
            passWord = "123";
        }
        JSONObject jsonObject = new JSONObject();
        jsonObject.put("passWord",passWord);
        resp.getWriter().println(jsonObject.toJSONString());
    }
}
```

在浏览器中输入 http://localhost:8081/JavaWeb02/index.jsp 链接，去调用该页面的 ajax 函数

报错：这是因为跨域导致的

解决：

　　首先我们要修改 index.jsp 页面的 ajax 请求：

```jsp
 1         <script type="text/javascript">
 							$.ajax({
 2             type:"get",
 3             async:false,
 4             url:"http://localhost:8080/JavaWeb01/getPassWordByUserNameServlet?userName=Tom",
 5             dataType:"jsonp",//数据类型为jsonp
 6             jsonp:"backFunction",//服务端用于接收callBack调用的function名的参数
 7             success:function (data) {
 8                 alert(data["passWord"]);
 9             },
10             error:function () {
11                 alert("error");
12             }
13 
14         });</script>
```

　　注意：我们修改了 dataType 的数据类型为 jsonp，并且新增了 jsonp 属性值为 “backFunction”。

　接着在 JavaWeb01 项目的 Servlet 中进行如下修改：

```java
 1 @WebServlet("/getPassWordByUserNameServlet")
 2 public class UserServlet extends HttpServlet{
 3     @Override
 4     protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
 5         String userName = req.getParameter("userName");
 6         String passWord = null;
 7         if(userName != null){
 8             passWord = "123";
 9         }
10         JSONObject jsonObject = new JSONObject();
11         jsonObject.put("passWord",passWord);
12         //1、第一种方法：*表示支持所有网站访问，也可以额外配置相应网站
13         //resp.setHeader("Access-Control-Allow-Origin", "*");
14 
15         //2、第二种方法：jsonp
16         String backFunction = req.getParameter("backFunction");
17         resp.getWriter().println(backFunction+"("+jsonObject.toJSONString()+")");
18         
19         //resp.getWriter().println(jsonObject.toJSONString());
20     }
21 }
```

在同源策略下，在某个服务器下的页面是无法获取到该服务器以外的数据的，即一般的ajax是不能进行跨域请求的。但 img、iframe 、script等标签是个例外，这些标签可以通过src属性请求到其他服务器上的数据。利用 script标签的开放策略，我们可以实现跨域请求数据，当然这需要服务器端的配合。 Jquery中ajax 的核心是通过 XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加 <script>标签来调用服务器提供的 js脚本。

方法二 

nginx

### 3. 防抖与节流

- 防抖：任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行（如果第一个正在等待执行的过程中第二个出现，则第一个不会执行，第二个重新计时）
- 节流：指定时间间隔内只会执行一次任务（如果一个操作开始了，就不会进行第二次操作，直到时间用完）

防抖：

```js
 
function debounce(fn) {
    let timeout = null; // 创建一个标记用来存放定时器的返回值      
    return function () {
        clearTimeout(timeout); // 每当用户输入的时候把前一个 setTimeout clear 掉        
        timeout = setTimeout(() => { // 然后又创建一个新的 setTimeout, 这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数          
            fn.apply(this, arguments);
        }, 500);
    };
}
function sayHi() {
    console.log('防抖成功');
}
var inp = document.getElementById('inp');
inp.addEventListener('input', debounce(sayHi)); // 防抖


```

节流：

```js

function throttle(fn) {
    let canRun = true; // 通过闭包保存一个标记     
    return function () {
        if (!canRun) return; // 在函数开头判断标记是否为 true，不为 true 则 return      
        canRun = false; // 立即设置为 false     
        setTimeout(() => { // 将外部传入的函数的执行放在 setTimeout 中       
            fn.apply(this, arguments);          // 最后在 setTimeout 执行完毕后再把标记设置为 true(关键) 表示可以执行下一次循环了。当定时器没有执行的时候标记永远是 false，在开头被 return 掉      
            canRun = true;
        }, 500);
    };
}
function sayHi(e) {
    console.log(e.target.innerWidth, e.target.innerHeight);
}
window.addEventListener('resize', throttle(sayHi));
```

### 4. let var 区别

`let`命令，用来声明局部变量。它的用法类似于`var`，但是所声明的变量，只在`let`命令所在的代码块内有效，而且有暂时性死区的约束。

### 5. hash router 与 history router。hash 变化的事件监听

https://blog.csdn.net/majunjie2017/article/details/78507551?utm_source=blogxgwz3

实现的原理：

1. hash 模式的原理是 onhashchange 事件，可以在 window 对象上监听这个事件。
2. history ：hashchange 只能改变 # 后面的代码片段，history api （pushState、replaceState、go、back、forward） 则给了前端完全的自由，通过在window对象上监听popState()事件。

### vue-router 的 hash 模式与 history 模式

提供两种模式的原因：

vue 是渐进式前端开发框架，为了实现 SPA ，需要引入前端路由系统（vue-router）。前端路由的核心是：改变视图的同时不会向后端发出请求。

为了达到这一目的，浏览器提供了 hash 和 history 两种模式。

1. hash ：hash 虽然出现在 URL 中，但不会被包含在 http 请求中，对后端完全没有影响，因此改变 hash 不会重新加载页面。
2. history ：history 利用了 html5 history interface 中新增的 pushState() 和 replaceState() 方法。这两个方法应用于浏览器记录栈，在当前已有的 back、forward、go 基础之上，它们提供了对历史记录修改的功能。只是当它们执行修改时，虽然改变了当前的 URL ，但浏览器不会立即向后端发送请求。

因此可以说， hash 模式和 history 模式都属于浏览器自身的属性，vue-router 只是利用了这两个特性（通过调用浏览器提供的接口）来实现路由。

- history 在刷新页面时，如果服务器中没有相应的响应或资源，就会出现404。因此，如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面
- hash 模式下，仅 # 之前的内容包含在 http 请求中，对后端来说，即使没有对路由做到全面覆盖，也不会报 404

### 6. monogodb和sql 的区别

mongodb与sql存储上的最大的区别，我个人认为是一个没有表结构，一个有表结构，在表结构。mongo的collection相当于sql的table，但collection只是document的集合，它对document并没有约束的，比如collection1中有doc1和doc2两个document，doc1和doc2的字段可以不同，相同的字段数据类型也可以不一样。sql有表结构，严格的定义了每一行有多少列，每一列是什么数据类型，所以每一行的长度，每一列的偏移量是可以算出来的。mongo既然没有表结构概念，那自然就没有什么表结构改变了。这里要注意的是，对已经存在的document增加一列，可能导致这个document变大，原来的位置放不下，这时候程序会把这个document移动到另外一个能放下的位置。

 ### 7. vue 

**Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。**

vue.js (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式JavaScript框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，方便与第三方库或既有项目整合。

Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。

与其他框架相同，vue允许你讲一个网页分割成可复用的组件，每个组件都包含属于自己的HTML、CSS、JavaScript以用来渲染网页中相应的地方。

**Vue.js 可以进行组件化开发，使代码编写量大大减少，读者更加易于理解。**

**相比传统的页面通过超链接实现页面的切换和跳转，Vue 使用路由不会刷新页面。**



| src  | 这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：assets: 放置一些图片，如logo等。components: 目录里面放了一个组件文件，可以不用。App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。main.js: 项目的核心文件 |
| ---- | ------------------------------------------------------------ |
|      |                                                              |

```python
<div id="vue_det">
    <h1>site : {{site}}</h1>
    <h1>url : {{url}}</h1>
    <h1>{{details()}}</h1>
</div>
<script type="text/javascript">
    var vm = new Vue({
        el: '#vue_det', # dom id 在div中调用
        data: {
            site: "菜鸟教程",
            url: "www.runoob.com",
            alexa: "10000"
        },
        methods: {
            details: function() {
                return  this.site + " - 学的不仅是技术，更是梦想！";
            }
        }
    })
</script>
```

https://www.zhihu.com/question/34219998

浏览器渲染html过程：DOM树解析->布局

你首先要明白什么是 DOM：浏览器解析 HTML 得来的一个树形逻辑对象： 将各种标签以及代码整理。

css解析器->样式表规则 放到对应dom树节点上。

布局

（从上到下，从左到右）将节点压入文档流

绘制

块级元素：独占一行

行级元素：依次排列

虚拟dom

```
Virtual DOM 本质上就是在 JS 和 DOM 之间做了一个缓存。可以类比 CPU 和硬盘，既然硬盘这么慢，我们就在它们之间加个缓存：既然 DOM 这么慢，我们就在它们 JS 和 DOM 之间加个缓存。CPU（JS）只操作内存（Virtual DOM），最后的时候再把变更写入硬盘（DOM）
```

DOM节点本身的属性非常多，这是DOM操作耗性能的一个点
而虚拟DOM只是用JS对象模拟出来的DOM结构
只需要模拟与数据操作相关的属性和方法
渲染速度自然会有所提升

然后是数据变化需要DOM重新渲染
之前的模板解析和渲染是通过Compile函数来完成的
采用了文档碎片代替了直接对页面中DOM元素的操作
在完成数据的更改后通过appendChild函数将真实的DOM插入到页面

虽然采用的是文档碎片
依然会将一些没有变化的部分重新渲染
造成性能浪费

虚拟DOM在重新渲染时有一个核心“**比对**”
通过Diff算法比较oldVnode和newVnode的差异
以**最小的代价**重新渲染页面



**v-bind** 指令被用来响应地更新 HTML 属性 样式绑定

class 与 style 是 HTML 元素的属性，用于设置元素的样式，我们可以用 v-bind 来设置样式属性。

Vue.js v-bind 在处理 class 和 style 时， 专门增强了它。表达式的结果类型除了字符串之外，还可以是对象或数组。

```js
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Vue 测试实例 - 菜鸟教程(runoob.com)</title>
<script src="https://cdn.staticfile.org/vue/2.2.2/vue.min.js"></script>
<style>
.active {
	width: 100px;
	height: 100px;
	background: green;
}
</style>
</head>
<body>
<div id="app">
  <div v-bind:class="{ 'active': isActive }"></div>
</div>

<script>
new Vue({
  el: '#app',
  data: {
    isActive: true
  }
})
</script>
</body>
</html>
```

```js
<div id="app">
    <div v-bind:style="{ color: activeColor, fontSize: fontSize + 'px' }">菜鸟教程</div>
</div>
```

**v-model** 指令来实现双向数据绑定：**v-model** 指令用来在 input、select、textarea、checkbox、radio 等表单控件元素上创建双向数据绑定，根据表单上的值，自动更新绑定的元素的值。

**v-on** 绑定事件

```js
<div id="app">
    <p>{{ message }}</p>
    <button v-on:click="reverseMessage">反转字符串</button>
</div>
    
<script>
new Vue({
  el: '#app',
  data: {
    message: 'Runoob!'
  },
  methods: {
    reverseMessage: function () {
      this.message = this.message.split('').reverse().join('')
    }
  }
})
</script>
```

**过滤器**

```js
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Vue 测试实例 - 菜鸟教程(runoob.com)</title>
<script src="https://cdn.staticfile.org/vue/2.2.2/vue.min.js"></script>
</head>
<body>
<div id="app">
  {{ message | capitalize }}
</div>
	
<script>
new Vue({
  el: '#app',
  data: {
	message: 'runoob'
  },
  filters: {
    capitalize: function (value) {
      if (!value) return ''
      value = value.toString()
      return value.charAt(0).toUpperCase() + value.slice(1)
    }
  }
})
</script>
</body>
</html>
```

将信息进行处理的函数 

```
<!-- 在两个大括号中 -->
{{ message | capitalize }}

<!-- 在 v-bind 指令中 -->
<div v-bind:id="rawId | formatId"></div>
```

**监听**

```js
<div id = "app">
    <p style = "font-size:25px;">计数器: {{ counter }}</p>
    <button @click = "counter++" style = "font-size:25px;">点我</button>
</div>
<script type = "text/javascript">
var vm = new Vue({
    el: '#app',
    data: {
        counter: 1
    }
});
vm.$watch('counter', function(nval, oval) {
    alert('计数器值的变化 :' + oval + ' 变为 ' + nval + '!');
});
</script>
```

**组件**

组件（Component）是 Vue.js 最强大的功能之一。

组件可以扩展 HTML 元素，封装可重用的代码。

组件系统让我们可以用独立可复用的小组件来构建大型应用，几乎任意类型的应用的界面都可以抽象为一个组件树：

注册一个全局组件语法格式如下：

```
Vue.component(tagName, options)
```

tagName 为组件名，options 为配置选项。注册后，我们可以使用以下方式来调用组件：

```
<tagName></tagName>
```

例子：

```js
<div id="app">
    <runoob></runoob>
</div>
 
<script>
// 注册
Vue.component('runoob', {
  template: '<h1>自定义组件!</h1>'
})
// 创建根实例
new Vue({
  el: '#app'
})
</script>
```

局部组件：

```js
<div id="app">
    <runoob></runoob>
</div>
 
<script>
var Child = {
  template: '<h1>自定义组件!</h1>'
}
 
// 创建根实例
new Vue({
  el: '#app',
  components: {
    // <runoob> 将只在父模板可用
    'runoob': Child
  }
})
</script>
```

prop 是子组件用来接受父组件传递过来的数据的一个自定义属性。

**Vue.js 路由**

本章节我们将为大家介绍 Vue.js 路由。

Vue.js 路由允许我们通过不同的 URL 访问不同的内容。

通过 Vue.js 可以实现多视图的单页Web应用（single page web application，SPA）。

**<router-link>** 是一个组件，该组件用于设置一个导航链接，切换不同 HTML 内容。 **to** 属性为目标地址， 即要显示的内容。

以下实例中我们将 vue-router 加进来，然后配置组件和路由映射，再告诉 vue-router 在哪里渲染它们。代码如下所示：

```js
<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Vue 测试实例 - 菜鸟教程(runoob.com)</title>
<script src="https://cdn.staticfile.org/vue/2.4.2/vue.min.js"></script>
<script src="https://cdn.staticfile.org/vue-router/2.7.0/vue-router.min.js"></script>
</head>
<body>
<div id="app">
  <h1>Hello App!</h1>
  <p>
    <!-- 使用 router-link 组件来导航. -->
    <!-- 通过传入 `to` 属性指定链接. -->
    <!-- <router-link> 默认会被渲染成一个 `<a>` 标签 -->
    <router-link to="/foo">Go to Foo</router-link>
    <router-link to="/bar">Go to Bar</router-link>
  </p>
  <!-- 路由出口 -->
  <!-- 路由匹配到的组件将渲染在这里 -->
  <router-view></router-view>
</div>

<script>
// 0. 如果使用模块化机制编程，導入Vue和VueRouter，要调用 Vue.use(VueRouter)

// 1. 定义（路由）组件。
// 可以从其他文件 import 进来
const Foo = { template: '<div>foo</div>' }
const Bar = { template: '<div>bar</div>' }

// 2. 定义路由
// 每个路由应该映射一个组件。 其中"component" 可以是
// 通过 Vue.extend() 创建的组件构造器，
// 或者，只是一个组件配置对象。
// 我们晚点再讨论嵌套路由。
const routes = [
  { path: '/foo', component: Foo },
  { path: '/bar', component: Bar }
]

// 3. 创建 router 实例，然后传 `routes` 配置
// 你还可以传别的配置参数, 不过先这么简单着吧。
const router = new VueRouter({
  routes // （缩写）相当于 routes: routes
})

// 4. 创建和挂载根实例。
// 记得要通过 router 配置参数注入路由，
// 从而让整个应用都有路由功能
const app = new Vue({
  router
}).$mount('#app')

// 现在，应用已经启动了！
</script>
</body>
</html>
```

### 8. v-if v-show

v-if 惰性，如果判断不成立不会渲染，只会在第一次成立后渲染。v-show会渲染，然后简单的进行切换。

v-if切换代价大。

v-show初始渲染代价大。

### 9. vue生命周期

Vue 实例从创建到销毁的过程，就是生命周期。也就是从开始创建、初始化数据、编译模板、挂载Dom→渲染、更新→渲染、卸载等一系列过程，我们称这是 Vue 的生命周期。

### 10. vue keep-alive

https://www.cnblogs.com/lxlin/p/8472395.html

作用：缓存组件

和路由搭配使用

```js
const routes = [
  {
    path: '/',
    name: 'home',
    component: Home,
    meta: {
      keepAlive: true // 需要被缓存
    }
  }, {
    path: '/:id',
    name: 'edit',
    component: Edit,
    meta: {
      keepAlive: false // 不需要被缓存
    }
  }
]
```

```js
<keep-alive>
    <router-view v-if="$route.meta.keepAlive">
        <!-- 这里是会被缓存的视图组件，比如 Home！ -->
    </router-view>
</keep-alive>

<router-view v-if="!$route.meta.keepAlive">
    <!-- 这里是不被缓存的视图组件，比如 Edit！ -->
</router-view>
```



### 9. 跨源资源共享（CORS）

**跨源资源共享** ([CORS](https://developer.mozilla.org/zh-CN/docs/Glossary/CORS)) （或通俗地译为跨域资源共享）是一种基于[HTTP](https://developer.mozilla.org/zh-CN/docs/Glossary/HTTP) 头的机制，该机制通过允许服务器标示除了它自己以外的其它[origin](https://developer.mozilla.org/zh-CN/docs/Glossary/源)（域，协议和端口），这样浏览器可以访问加载这些资源。跨源资源共享还通过一种机制来检查服务器是否会允许要发送的真实请求，该机制通过浏览器发起一个到服务器托管的跨源资源的"预检"请求。在预检中，浏览器发送的头中标示有HTTP方法和真实请求中会用到的头。

什么时候使用：

- 前文提到的由 [`XMLHttpRequest`](https://developer.mozilla.org/zh-CN/docs/Web/API/XMLHttpRequest) 或 [Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API) 发起的跨源 HTTP 请求。
- Web 字体 (CSS 中通过` @font-face `使用跨源字体资源)
- 使用 `drawImage` 将 Images/video 画面绘制到 canvas

若干访问控制场景

简单请求 某些请求不会触发 [CORS 预检请求](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS#Preflighted_requests)。本文称这样的请求为“简单请求”

*使用下列方法之一：

- [`GET`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/GET)

- [`HEAD`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/HEAD)

- POST

  Content-Type`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Type) 的值仅限于下列三者之一：

  - `text/plain`
  - `multipart/form-data`
  - `application/x-www-form-urlencoded`

```js
var invocation = new XMLHttpRequest();
var url = 'http://bar.other/resources/public-data/';
   
function callOtherDomain() {
  if(invocation) {    
    invocation.open('GET', url, true);
    invocation.onreadystatechange = handler;
    invocation.send(); 
  }
}
```

分别检视请求报文和响应报文：

```shell
GET /resources/public-data/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Referer: http://foo.example/examples/access-control/simpleXSInvocation.html
Origin: http://foo.example


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 00:23:53 GMT
Server: Apache/2.0.61 
Access-Control-Allow-Origin: *
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Transfer-Encoding: chunked
Content-Type: application/xml

[XML Data]
```

预检请求

“需预检的请求”要求必须首先使用 [`OPTIONS`](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Methods/OPTIONS)  方法发起一个预检请求到服务器，以获知服务器是否允许该实际请求。"预检请求“的使用，可以避免跨域请求对服务器的用户数据产生未预期的影响。

```html
OPTIONS /resources/post-here/ HTTP/1.1
Host: bar.other
User-Agent: Mozilla/5.0 (Macintosh; U; Intel Mac OS X 10.5; en-US; rv:1.9.1b3pre) Gecko/20081130 Minefield/3.1b3pre
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8
Accept-Language: en-us,en;q=0.5
Accept-Encoding: gzip,deflate
Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7
Connection: keep-alive
Origin: http://foo.example
Access-Control-Request-Method: POST 
Access-Control-Request-Headers: X-PINGOTHER, Content-Type  //预检 带有这两个首部字段


HTTP/1.1 200 OK
Date: Mon, 01 Dec 2008 01:15:39 GMT
Server: Apache/2.0.61 (Unix)
Access-Control-Allow-Origin: http://foo.example
Access-Control-Allow-Methods: POST, GET, OPTIONS
Access-Control-Allow-Headers: X-PINGOTHER, Content-Type
Access-Control-Max-Age: 86400
Vary: Accept-Encoding, Origin
Content-Encoding: gzip
Content-Length: 0
Keep-Alive: timeout=2, max=100
Connection: Keep-Alive
Content-Type: text/plain
```

### 10. webpack

webpack的核心是一切皆模块，所以它其实本质上就是个静态模块打包器。当 webpack 处理应用程序时，它会递归地构建一个依赖关系图，其中包含应用程序需要的每个模块，然后将所有这些模块打包成一个或多个 bundle。官网显示的这幅图很形象地描述了这个过程

```
- src
- common 公用代码库
- pages
  - [活动名称]\_[h5|pc]
    - index.js
    - index.html
```

**多页面入口配置**

```js
const webpack = require("webpack");
const glob = require("glob");

function getEntry() {
  const entry = {};
  //读取src目录所有page入口
  glob.sync('./src/pages/*/*/index.js')
      .forEach(function (filePath) {
          var name = filePath.match(/\/pages\/(.+)\/index.js/);
          name = name[1];
          entry[name] = filePath;
      });
  return entry;
};

module.exports = {
  mode: 'development',
  // 多入口
  entry: getEntry(),
}
```

```js
output: {
    publicPath: CDN.js,
    filename: '[name].[chunkhash].js',
    chunkFilename: '[name]_[chunkhash].min.js',
    path: distDir,
},
```



### 11. js数据类型 null undefined

类型

**值类型(基本类型)**：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。

**引用数据类型**：对象(Object)、数组(Array)、函数(Function)。

Undefined 这个值表示变量不含有值。

可以通过将变量的值设置为 null 来清空变量。

**JavaScript中Null和Undefined的区别**

**Null：**

null是js中的关键字，表示空值，null可以看作是object的一个特殊的值，如果一个object值为空，表示这个对象不是有效对象。

**Undefined:**

undefined不是js中的关键字，其是一个全局变量，是Global的一个属性，以下情况会返回undefined:

1）使用了一个未定义的变量；var i;

2）使用了已定义但未声明的变量；

3）使用了一个对象属性，但该属性不存在或者未赋值；

4)调用函数时，该提供的参数没有提供：

```
function func(a){``  ``console.log(a);    ``}``func();``//undefined
```

 5)函数没有返回值时，默认返回undefined

```
var` `aa=func();``aa;``//undefined
```

**相同点：**

都是原始类型的值，保存在栈中变量本地

**两者的区别：**

1.类型不一样：

```
console.log(typeOf undefined);``//undefined` `console.log(typeOf ``null``);``//object
```

 

2.转化为值时不一样：undefined为NaN ,null为0

```
console.log(Number(undefined));``//NaN``console.log(Number(10+undefined));``//NaN` `console.log(Number(``null``));``//0``console.log(Number(10+``null``));``//10
```

 3.undefined===null;//false

  undefined==null;//true

**何时使用：**

**null当使用完一个比较大的对象时，需要对其进行释放内存时，设置为null;**

```
var` `arr=[``"aa"``,``"bb"``,``"cc"``];``arr=``null``;``//释放指向数组的引用
```

 ### 12. 数组去重

set

```
function(array){
	return Array.from(New Set(array));
}
```

### 13. 浏览器缓存

![截屏2020-12-10 下午12.07.31](/Users/una/newroot/本地图床/截屏2020-12-10 下午12.07.31.png)

![截屏2020-12-10 下午12.08.13](/Users/una/newroot/本地图床/截屏2020-12-10 下午12.08.13.png)

![截屏2020-12-10 下午12.08.48](/Users/una/newroot/本地图床/截屏2020-12-10 下午12.08.48.png)

### 14. 变量提升

变量提升：函数声明和变量声明总是会被解释器悄悄地被"提升"到方法体的最顶部。

```js
x = 5; // 变量 x 设置为 5

elem = document.getElementById("demo"); // 查找元素 
elem.innerHTML = x;                     // 在元素中显示 x

var x; // 声明 x
```

```js
var x; // 声明 x
x = 5; // 变量 x 设置为 5

elem = document.getElementById("demo"); // 查找元素 
elem.innerHTML = x;  
```

JavaScript 初始化不会提升.

```js
var x = 5; // 初始化 x

elem = document.getElementById("demo"); // 查找元素 
elem.innerHTML = x + " " + y;           // 显示 x 和 y

var y = 7; // 初始化 y
```

相同

### 15. 三列登高

```css
.Article>li {
  display: table-cell; // 默认登高
  width: 200px;
  border-left: solid 5px currentColor;
  border-right: solid 5px currentColor;
  color: #fff;
  background: #4577dc;
}
```

### 16. this

### 17. rem布局

rem和em很容易混淆，其实两个都是css的单位，并且也都是相对单位，现有的em，css3才引入的rem，在介绍rem之前，我们先来了解下em

em可以让我们的页面更灵活，更健壮，比起到处写死的px值，em似乎更有张力，改动父元素的字体大小，子元素会等比例变化，这一变化似乎预示了无限可能。em做弹性布局的缺点还在于牵一发而动全身，一旦某个节点的字体大小发生变化，那么其后代元素都得重新计算，X﹏X

rem取值分为两种情况，设置在根元素时和非根元素时，举个例子

```css
/* 作用于根元素，相对于原始大小（16px），所以html的font-size为32px*/
html {font-size: 2rem}

/* 作用于非根元素，相对于根元素字体大小，所以为64px */
p {font-size: 2rem}
```

其实**rem布局的本质是等比缩放**，一般是基于宽度，试想一下如果UE图能够等比缩放，那该多么美好啊

假设我们将屏幕宽度平均分成100份，每一份的宽度用x表示，x = 屏幕宽度 / 100，如果将x作为单位，x前面的数值就代表屏幕宽度的百分比

```css
p {width: 50x} /* 屏幕宽度的50% */ 
```

如果想要页面元素随着屏幕宽度等比变化，我们需要上面的x单位，不幸的是css中并没有这样的单位，幸运的是在css中有rem，通过rem这个桥梁，可以实现神奇的x

通过上面对rem的介绍，可以发现，如果子元素设置rem单位的属性，通过更改html元素的字体大小，就可以让子元素实际大小发生变化。如果让html元素字体的大小，恒等于屏幕宽度的1/100，那1rem和1x就等价了

```css
html {font-size: 16px}
p {width: 2rem} /* 32px*/

html {font-size: 32px}
p {width: 2rem} /*64px*/
```

**比Rem更好的方案**

上面提到想让页面元素随着页面宽度变化，需要一个新的单位x，x等于屏幕宽度的百分之一，css3带来了rem的同时，也带来了vw和vh

> vw —— 视口宽度的 1/100；vh —— 视口高度的 1/100 —— MDN

聪明的你也许一经发现，这不就是单位x吗，没错根据定义可以发现1vw=1x，有了vw我们完全可以绕过rem这个中介了，下面两种方案是等价的，可以看到vw比rem更简单，毕竟rem是为了实现vw么

```css
/* rem方案 */
html {fons-size: width / 100}
p {width: 15.625rem}

/* vw方案 */
p {width: 15.625vw}
```

vw还可以和rem方案结合，这样计算html字体大小就不需要用js了

```css
html {fons-size: 1vw} /* 1vw = width / 100 */
p {width: 15.625rem}
```

虽然vw各种优点，但是vw也有缺点，首先vw的兼容性不如rem好，使用之前要看下

| 兼容性 | Ios | 安卓 |

| ---- | ---- | ---- |

| rem | 4.1+ | 2.1+ |

| vw | 6.1+ | 4.4+ |

### 18. nodejs和vue的关系

Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。 

Node 是一个让 JavaScript 运行在[服务端](https://baike.so.com/doc/5988965-6201932.html)的开发平台，它让 JavaScript 成为与[PHP](https://baike.so.com/doc/5336503-5571942.html)、[Python](https://baike.so.com/doc/1790119-1892991.html)、[Perl](https://baike.so.com/doc/5106225-5334848.html)、[Ruby](https://baike.so.com/doc/4990463-5214197.html) 等服务端语言平起平坐的[脚本语言](https://baike.so.com/doc/2874347-3033293.html)。 发布于2009年5月，由Ryan Dahl开发，实质是对Chrome V8引擎进行了封装。

Node对一些特殊用例进行优化，提供替代的[API](https://baike.so.com/doc/24846846-25783482.html)，使得V8在非浏览器环境下运行得更好。V8引擎执行Javascript的速度非常快，性能非常好。 Node是一个基于Chrome JavaScript运行时建立的平台， 用于方便地搭建响应速度快、易于扩展的网络应用。Node 使用[事件驱动](https://baike.so.com/doc/357634-378877.html)， 非阻塞[I/O](https://baike.so.com/doc/3034590-3199433.html) 模型而得以轻量和高效，非常适合在分布式设备上运行数据密集型的实时应用。

官网上对其特点描述为：

1. 它是一个Javascript运行环境
2. 依赖于Chrome V8引擎进行代码解释
3. 事件驱动
4. 非阻塞I/O
5. 轻量、可伸缩，适于实时数据交互应用
6. 单进程，单线程

**相对于传统的JavaScript来说，Node.js 是一个运行在服务端的框架**，它的底层就使用了 V8 引擎。我们知道 Apache + PHP 以及 Java 的 Servlet 都可以用来开发动态网页，Node.js 的作用与他们类似，只不过是使用 JavaScript 来开发，它大大提升了开发的性能以及便利。

**webpack是基于 Node.js的前端项目部署打包工具。**

Vue.js 的核心是一个允许你采用简洁的模板语法来声明式的将数据渲染进 DOM 的系统。。Vue.js可以在html里直接引用后使用，等到与Vue一起配合使用的第三方应用的库或框架多起来后，一个个从html里引入就不方便了，所有要借用node.js中的npm管理包的引入，是方便包管理。

使用Vue.js开发的前端项目如何部署？我们用到node.js中的程序打包工具比如webpack（node.js中的程序部署打包工具），可以直接require引入之后将不同模块打包成单个js文件。同时这些工具提供各种自动化处理，让前端开发更爽。

在NODE中集成VUE开发前端项目，所以，先安装Node,使用Node的npm先安装Vue，然后再安装vue-cli脚手架，最后通过vue-cli脚手架构建前端项目。

### 19. 事件冒泡与事件委托

https://www.cnblogs.com/lauzhishuai/p/11263210.html

事件冒泡：JS中当出发某些具有冒泡性质的事件是，首先在触发元素寻找是否有相应的注册事件，如果没有再继续向上级父元素寻找是否有相应的注册事件作出相应，这就是事件冒泡。

事件委托：利用事件冒泡的特性，将本应该注册在子元素上的处理事件注册在父元素上，这样点击子元素时发现其本身没有相应事件就到父元素上寻找作出相应。这样做的优势有：1.减少DOM操作，提高性能。2.随时可以添加子元素，添加的子元素会自动有相应的处理事件。

 性能优化的主要思想之一就是减少DOM操作的原因，如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能；举个例子：页面上有这么一个节点树，div>ul>li>a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a>li>ul>div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。

适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。

### 20. addEventlisner

https://www.jianshu.com/p/bad857d649f2



从[官方文档](https://developer.mozilla.org/en-US/docs/Web/API/EventTarget/addEventListener)看，addEventListener 方法使用如下：

> ```javascript
> target.addEventListener(type, listener[, options]); 
> target.addEventListener(type, listener[, useCapture]);
> ```

主要关注下第三个参数，可以设置为bool类型（useCapture）或者object类型(options)。

- options包括三个布尔值选项：
  - capture: 默认值为false（即 使用事件冒泡）. 是否使用事件捕获；
  - once: 默认值为false. 是否只调用一次，if true，会在调用后自动销毁listener
  - passive: if true, 意味着listener永远不远调用preventDefault方法，如果又确实调用了的话，浏览器只会console一个warning，而不会真的去执行preventDefault方法。**根据规范，默认值为false. 但是chrome, Firefox等浏览器为了保证滚动时的性能，在document-level nodes(Window, Document, Document.body)上针对touchstart和touchmove事件将passive默认值改为了true**， 保证了在页面滚动时不会因为自定义事件中调用了preventDefault而阻塞页面渲染。
- useCapture: 默认值为false（即 使用事件冒泡）。

### 21. canvas



https://developer.mozilla.org/zh-CN/docs/Web/API/Canvas_API/Tutorial/Basic_usage

```html
<html>
  <head>
    <title>Canvas tutorial</title>
    <script type="text/javascript">
      function draw(){
        var canvas = document.getElementById('tutorial');
        if (canvas.getContext){
          var ctx = canvas.getContext('2d');
        }
      }
    </script>
    <style type="text/css">
      canvas { border: 1px solid black; }
    </style>
  </head>
  <body onload="draw();">
    <canvas id="tutorial" width="150" height="150"></canvas>
  </body>
</html>
```

## SAP

面经 ： https://fun4wut.github.io/2019/05/17/SAP-VT%E9%A1%B9%E7%9B%AE%E9%9D%A2%E7%BB%8F/#%E7%BC%96%E7%A8%8B%E9%A2%98

ABAP 

SAP 的 模块https://zhuanlan.zhihu.com/p/149188367?utm_source=qq

### 1. 多路复用



## 腾讯后台！！！！

https://draveness.me/golang/

# 字节后台

![n](/Users/una/newroot/本地图床/F7A0D34B210F716FF4B951EE68DB0F99.png)

### 1. 操作系统的系统调用（用户态和内核态）

系统调用：由[操作系统](https://baike.baidu.com/item/操作系统/192)实现提供的所有系统调用所构成的集合即[程序接口](https://baike.baidu.com/item/程序接口/150383)或应用编程接口(Application Programming Interface，API)。是[应用程序](https://baike.baidu.com/item/应用程序)同系统之间的接口。

系统调用过程：用户程序只在用户态下运行，有时需要访问系统核心功能，这时通过系统调用[接口](https://baike.baidu.com/item/接口/15422203)使用系统调用。系统调用把[应用程序](https://baike.baidu.com/item/应用程序)的请求传给[内核](https://baike.baidu.com/item/内核)，调用相应的内核[函数](https://baike.baidu.com/item/函数)完成所需的处理，将处理结果返回给应用程序。

系统调用调用方式：系统调用必须通过软中断机制首先进入系统核心，然后才能转向相应的命令处理程序。普通过程调用可以直接由调用过程转向被调用过程。

系统调用存在意义：

当操作系统接收到系统调用请求后，会让处理器进入内核模式，从而执行诸如**I/O操作**，**修改基址寄存器**（防止缓冲区溢出攻击）内容等指令，而当处理完系统调用内容后，操作系统会让处理器返回用户模式，来执行用户代码。

*基址寄存器和界限寄存器意义：防止缓冲区溢出攻击。一个进程可以轻易的修改进程的内存空间中的数据来使另一个进程异常或达到一些目的，因此操作系统必须保证每一个进程都能安全的执行。这两个寄存器中的内容用硬件限制了对储存器的存取指令所访问的储存器的地址。这样就可以在系统切换进程时写入这两个寄存器的内容到该进程被分配的地址范围，从而避免恶意软件。*

**系统调用和普通调用的区别**

1. 调用方法不同。系统调用必须通过软中断机制首先进入系统核心，然后才能转向相应的命令处理程序。普通过程调用可以直接由调用过程转向被调用过程。
2. 返回问题。在采用抢先式调度的系统中，当系统调用返回时，要重新进行调度分析――是否有更高优先级的任务就绪。普通的过程调用直接返回调用过程继续执行。

### 2. 进程线程的区别与通信方式

**进程是资源分配的最小单位，线程是CPU调度的最小单位**

* 切换进程需要消耗资源，线程切换消耗资源较少
* 线程依附进程，一般情况下，一个进程对多个线程。也有进程与线程M-N关系。
* 进程与进程不能共享数据，同一进程下不同线程间数据很易共享，线程需要考虑是否需要互斥锁。
* 进程间不会相互影响，一般情况下，一个线程挂掉将导致整个进程挂掉
* 进程可以拓展到多机，线程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上）

通信方式：

### 3. fork

fork 是一个系统调用

调用fork(),当控制转移到内核中的fork代码后，内核开始做： 
1.分配新的内存块和内核数据结构给子进程。 
2.将父进程部分数据结构内容拷贝至子进程。 
3.将子进程添加到系统进程列表。 
4.fork返回开始调度器，调度。 

在父进程创建子进程。返回两次，父进程返回0，子进程返回非0

fork的常规用法 
1.一个父进程希望复制自己，使得子进程同时执行不同的代码段，例如：父进程等待客户端请求，生成一个子进程来等待请求处理。 
2.一个进程要执行一个不同的程序。

### 3. 并发并行

:并发是指一个处理器同时处理多个任务。并行是指多个处理器或者是多核的处理器同时处理多个不同的任务。并发是逻辑上的同时发生(simultaneous),而并行是物理上的同时发生。

### 4. 集线器 网管 路由器 交换机

https://zhidao.baidu.com/question/1900063355243427820.html

**集线器：**

集线器是物理层（OSI第一层）设备，主要作用是将信号进行***接受-恢复放大-发送\***，双绞线、光纤在传输信号的时候，随着距离的增大，信号会减弱造成失真，借助集线器可以让信号传播更远的距离；同时集线器上有很多接口，能够扩展终端数量扩大 LAN 的规模。

**交换机与集线器的区别**　　

1．从OSI体系结构来看，集线器属于第一层物理层设备，而交换机属于OSI的第二层数据链路层设备。也就是说集线器只是对数据的传输起到同步、放大和整形的作用，对于数据传输中的短帧=碎片等无法进行有效的处理，不能保证数据传输的完整性和正确性；而交换机不但可以对数据的传输做到同步、放大和整形，而且可以过滤短帧、碎片等。
2．从工作方式看，集线器是一种广播模式，也就是说集线器的某个端口工作的时候，其它所有端口都能够收听到信息，容易产生广播风暴，当网络较大时网络性能会受到很大影响；而交换机就能够避免这种现象，当交换机工作的时候，只有发出请求的端口与目的端口之间相互响应而不影响其它端口，因此交换机就能够隔离冲突域并有效地抑制广播风暴的产生。
3．从带宽来看，集线器不管有多少个端口，所有端口都共享一条带宽，在同一时刻只能有两个端口传送数据，其它端口只能等待，同时集线器只能工作 在半双工模式下；而对于交换机而言，每个端口都有一条独占的带宽，当两个端口工作时不影响其它端口的工作，同时交换机不但可以工作 在半双工模式下而且可以工作在全双工模式下。

**交换机与路由器的区别**　　

***传统交换机从网桥发展而来，属于OSI第二层即数据链路层设备。*它根据MAC地址寻址**，通过站表选择路由，站表的建立和维护由交换机自动进行。***路由器属于OSI第三层即网络层设备*，它根据IP地址进行寻址**，通过路由表路由协议产生。交换机最大的好处是快速，由于交换机只须识别帧中MAC地址，直接根据MAC地址产生选择转发端口算法简单，便于ASIC实现，因此转发速度极高。

**网关**

网关(Gateway)又称网间连接器、[协议转换](https://baike.baidu.com/item/协议转换)器。网关在**网络层**以上实现[网络互连](https://baike.baidu.com/item/网络互连/108997)，是复杂的网络互连设备，仅用于两个高层协议不同的网络互连。网关既可以用于[广域网](https://baike.baidu.com/item/广域网/422004)互连，也可以用于[局域网](https://baike.baidu.com/item/局域网)互连。 网关是一种充当转换重任的[计算机系统](https://baike.baidu.com/item/计算机系统/7210959)或设备。使用在不同的[通信协议](https://baike.baidu.com/item/通信协议/3351624)、数据格式或语言，甚至[体系结构](https://baike.baidu.com/item/体系结构/8174145)完全不同的两种系统之间，网关是一个翻译器。与[网桥](https://baike.baidu.com/item/网桥/99310)只是简单地传达信息不同，网关对收到的信息要重新打包，以适应目的系统的需求。同层--[应用层](https://baike.baidu.com/item/应用层/4329788)。

### 网桥

网桥将两个相似的网络连接起来，并对网络数据的流通进行管理。它工作于**[数据链路层](https://baike.baidu.com/item/数据链路层)**，不但能扩展网络的距离或范围，而且可提高网络的性能、可靠性和安全性。

### 5. LAN与VLAN

https://www.jianshu.com/p/bcc4feffc5d6

**LAN** 表示 Local Area Network，本地局域网。
一个 LAN 表示一个广播域，含义是：LAN 中的所有成员都会收到任意一个成员发出的广播包。

**ARP协议**：LAN中获取其他主机mac地址的协议。A 发信息给 C，A 并不知道 C 的 MAC 地址。此时通过 ARP 协议（Address Resolution Protocol；地址解析协议；）获取 C 的 MAC 地址，A 先要广播一个包含目标 IP 地址的 ARP 请求到链接在集线器上的所有设备上，C 接受到广播后返回 MAC 地址给 A，其他设备则丢弃信息。至此已经建立设备间通信的准备条件。

- 链接在集线器中的设备都在同一个冲突域和广播域中。此时的冲突域就是广播域。简单理解就是在这种布局中，一次只能一台设备发送信号且其他设备都能接受该信号。
- 集线器是物理层（OSI第一层）设备，主要作用是将信号进行**接受-恢复放大-发送**。同一集线器上的所有设备共享带宽，如果设备数量过多的话，会造成链路拥堵，严重的会产生广播风暴。
- 使用**交换机**可以把一个大的冲突域划分成多个小的冲突域，这样可以缩减冲突域的范围，降低数据拥堵。交换机的一个端口对应一个单独的冲突域。这样一来一个大的广播域就分成了多个小的冲突域。但注意的是，**这整个网络仍是一个广播域**。

* 使用**路由器**对广播域进行隔离。当路由器收到广播时，会把它自动丢弃，不会转发到路由器的其他端口，实现了广播域的分割

**VLAN 虚拟局域网**

虚拟局域网（VLAN）是在局域网（LAN）的逻辑上划分成多个广播域，每一个广播域就是一个 VLAN。

下图为交换机划分虚拟局域网。交换机把一个广播域划分成了3个广播域，物理上这些设备在一个交换机上，但是逻辑上已经分别划分到三个交换机上，所以会有三个局域网（虚拟局域网），三个广播域。

![截屏2020-12-13 下午7.35.06](/Users/una/newroot/本地图床/截屏2020-12-13 下午7.35.06.png)

交换机划分 VLAN 说明，VLAN1 这个虚拟局域网编号，一般工作于管理组，所以普通 VLAN 都是从 2 开始编号，默认情况下，所有虚拟局域网都隶属于 VALN1。

https://zhidao.baidu.com/question/2012380553244417588.html?qbl=relate_question_3&word=LAN%20VLAN

**VLAN的好处**

，VLAN与传统的LAN相比，具有以下优势:
　　1、控制广播风暴
　　网络的管理是一个需要大量广播信息带宽消耗，VLAN分段将建立在广播风暴的内部，其余的网段将不受到干预，这对于以往的局域网来讲，其中的优势就不言而喻了，它将使得带宽的利用率使用达到最大化减少主干网的流量，使得网络的速度更加快捷。
　　2、3.2增强网络的安全性
　　以往大家共用一个LAN广播区域，其安全性肯定受到挑战，现在使用VLAN可以将客户的特定性进行控制，可以优先选择设置，限制一些没有经过许可的用户以及网络成员对网络带宽的使用，提高检测的业务能力。
　　3、增强网络答理
　　VLAN可以对整个网络进行答理，能够将网络的业务需求进行调整，当网络拥堵时，可以选择性的分配用户业务能力，对网答来讲，更加方便、快捷和明了，这就增强的网络的答理能力以及灵活性。为网答人员减轻了工作压力。VLAN还可以减少因网络成员变化所带来的费用问题。在添加、删除和移动网络成员时，不用重新布线，也不用直接对成员进行配置。

### 6. hashmap的实现 -go

两个关键点 —— 哈希函数和冲突解决方法。

（1）哈希函数

哈希函数应该能够将**不同键映射到不同的索引**上。**哈希函数的输出范围大于输入范围**，让哈希函数的结果能够尽可能的均匀分布，不均匀的哈希函数会带来更多的哈希冲突以及更差的读写性能。

（2）冲突解决

**开放寻址法**：

当我们向当前哈希表写入新的数据时，如果发生了冲突，就会将键值对写入到下一个索引不为空的位置。如果我们使用开放寻址法来实现哈希表，那么实现哈希表底层的数据结构就是数组。当需要查找某个键对应的值时，会从索引的位置开始线性探测数组，找到目标键值对或者空内存就意味着这一次查询操作的结束。**装载因子**，它是数组中元素的数量与数组大小的比值。

```go
index := hash("author") % array.len
```

**拉链法：**

大多数的编程语言。实现拉链法一般会使用数组加上链表，不过一些编程语言会在拉链法的哈希中引入红黑树以优化性能，拉链法会使用链表数组作为哈希底层的数据结构，我们可以将它看成可以扩展的二维数组。

装载因子:=元素数量÷桶数量 

装载因子越大哈希表性能越低。

```go
index := hash("Key6") % array.len
```

当哈希表的装载因子较大时会触发哈希的扩容，创建更多的桶来存储哈希中的元素，保证性能不会出现严重的下降。

go的map实现

1. 使用拉链法。
2. 用于选择桶序号的是哈希的最低几位，对桶数取模选择桶号。
3. 而用于加速访问的是哈希的高 8 位。每个桶存储八个建值对，存储hash（key）的高八位。如果满了会使用溢出桶，接在桶后。
4. 当溢出桶过多，或者装载因子大于6.5，会实现扩容，桶数量会变成之前的两倍，每个旧桶的元素会都分流到新创建的两个桶中。

### 7. linux下 .text .bss .data(堆，栈，静态存储区)的概念 段式内存管理

https://cloud.tencent.com/developer/article/1683191

.text即为代码段

BSS : linux 段式存储 存放程序中未初始化的全局变量，一般在初始化时 BSS 段部分将会清零。BSS 段属于静态内存分配，即程序一开始就将其清零了。

Data: 已初始化的全局变量的一块内存区域，包括堆，栈，静态存储区

* 堆 被动态分配的内存段，它的大小并不固定，可动态扩张或缩减。 malloc扩张；free缩减
* 栈  用户存放程序临时创建的局部变量、参数和返回地址，用来保存/恢复调用现场。
* 静态存储区 已初始化的全局变量、静态变量和常量。



text和data段都在可执行文件中，由系统从可执行文件中加载；而BSS段不在可执行文件中，由系统初始化。

### 8. linux 文件系统

https://blog.csdn.net/yuexiaxiaoxi27172319/article/details/45241923

http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/Linux.html#%E5%88%86%E5%8C%BA%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F

在*LINUX系统中有一个重要的概念：一切都是文件。* 其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来。一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。

**文件化优势：**

* 实现了设备无关性
* UNIX 权限模型也是围绕文件的概念来建立的，所以对设备也就可以同样处理了。

内核态操作：硬盘驱动，文件系统，虚拟文件系统，以及系统调用

用户态操作：对磁盘的读写访问操作

**文件系统分层**

->硬盘驱动

 ->General Block Device Layer: 封装硬盘api，为内核提供接口 

->文件系统（不同类型：ext3，ext4）

->虚拟文件系统(封装不同文件系统api) 

->系统调用

**文件系统组成**

- inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；
- block：记录文件的内容，文件太大时，会占用多个 block。

其他

- superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；
- block bitmap：记录 block 是否被使用的位图。

**读取**

Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。

在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。



而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。

磁盘碎片：指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。

**inode**

内容：

- 权限 (read/write/excute)；
- 拥有者与群组 (owner/group)；
- 容量；
- 建立或状态改变的时间 (ctime)；
- 最近读取时间 (atime)；
- 最近修改时间 (mtime)；
- 定义文件特性的旗标 (flag)，如 SetUID...；
- 该文件真正内容的指向 (pointer)。

特点

- 每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)；
- 每个文件都仅会占用一个 inode。

inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用让 inode 记录的引用 block 块记录引用信息。

目录：

建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。

可以看到文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的写权限有关。

日志：

如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。

ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。

挂载：

挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。

目录配置：

为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下：

- / (root, 根目录)
- /usr (unix software resource)：所有系统默认软件都会安装到这个目录；
- /var (variable)：存放系统或程序运行过程中的数据文件。

<img src="/Users/una/newroot/本地图床/截屏2020-12-14 上午1.07.51.png" alt="截屏2020-12-14 上午1.07.51" style="zoom:50%;" />

### 9. linux 文件

http://www.cyc2018.xyz/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/Linux/Linux.html#%E6%96%87%E4%BB%B6%E5%B1%9E%E6%80%A7

> ls 文件

```shell
drwxr-xr-x 3 root root 17 May 6 00:14 .config
```

- drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段
- 3：链接数
- root：文件拥有者
- root：所属群组
- 17：文件大小
- May 6 00:14：文件最后被修改的时间
- .config：文件名

常见的文件类型及其含义有：

- d：目录
- -：文件
- l：链接文件





**权限：**

用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。

9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。

修改权限

```shell
chmod 754 .bashrc
```

默认权限

- 文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。
- 目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。



链接：

* 实体链接 

```
ln A B
```

不能跨越文件系统、不能对目录进行链接。

在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。

删除任意一个条目，文件还是存在，只要引用数量不为 0。

* 符号链接

```
ln -s A B 
```

因为记录的是路径，所以可以为目录建立符号链接。

符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。



文件时间有以下三种（touch更新）：

- modification time (mtime)：文件的内容更新就会更新；
- status time (ctime)：文件的状态（权限、属性）更新就会更新；
- access time (atime)：读取文件时就会更新。



指令：

压缩：gzip、bzip2、xz 

打包：tar 

解压缩：tar

zsh插件x 解压各种文件





### 9. 开机过程

